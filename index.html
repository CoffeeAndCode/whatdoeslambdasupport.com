<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>What Does AWS Lambda Support?</title>
    <meta name="description" content="An autogenerated static website to show what JavaScript functionality is supported out of the box with AWS Lambda with node.js.">
    <meta name="keywords" content="aws, lambda, node.js, javascript, support">
    <meta name="author" content="Coffee and Code">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" integrity="sha384-1q8mTJOASx8j1Au+a5WDVnPi2lkFfwwEAa8hDDdjZlpLegxhjVME1fgjWPGmkzs7" crossorigin="anonymous">
  </head>
  <body>
    <nav class="navbar navbar-inverse">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">Versions</a>
        </div>

        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <li class="active"><a href="/">v4.3.2 <span class="sr-only">(current)</span></a></li>
            <li><a href="http://v0-10-4.whatdoeslambdasupport.com/">v0.10.4</a></li>
          </ul>
        </div>
      </div>
    </nav>

    <div class="container">
      <h1>What does AWS Lambda's Node.js environment support?</h1>

      <iframe src="https://ghbtns.com/github-btn.html?user=coffeeandcode&repo=whatdoeslambdasupport.com&type=star&count=false&size=large" frameborder="0" scrolling="0" width="160px" height="30px"></iframe>

      <h2>ES5 Features</h2>
      <ul>
          <li>
            SUCCESS - Object/array literal extensions

              <ul>
                <li>
                  SUCCESS - Getter accessors
                    <pre><code>(function (){
  return ({ get x(){ return 1 } }).x &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Setter accessors
                    <pre><code>(function (){
  var value &#x3D; 0;
  ({ set x(v){ value &#x3D; v; } }).x &#x3D; 1;
  return value &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Trailing commas in object literals
                    <pre><code>(function (){
  return { a: true, }.a &#x3D;&#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Trailing commas in array literals
                    <pre><code>(function (){
  return [1,].length &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Reserved words as property names
                    <pre><code>(function (){
  return ({ if: 1 }).if &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Object static methods

              <ul>
                <li>
                  SUCCESS - Object.create
                    <pre><code>(function (){
  return typeof Object.create &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.defineProperty
                    <pre><code>(function (){
  return typeof Object.defineProperty &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.defineProperties
                    <pre><code>(function (){
  return typeof Object.defineProperties &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getPrototypeOf
                    <pre><code>(function (){
  return typeof Object.getPrototypeOf &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.keys
                    <pre><code>(function (){
  return typeof Object.keys &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.seal
                    <pre><code>(function (){
  return typeof Object.seal &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.freeze
                    <pre><code>(function (){
  return typeof Object.freeze &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.preventExtensions
                    <pre><code>(function (){
  return typeof Object.preventExtensions &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isSealed
                    <pre><code>(function (){
  return typeof Object.isSealed &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isFrozen
                    <pre><code>(function (){
  return typeof Object.isFrozen &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isExtensible
                    <pre><code>(function (){
  return typeof Object.isExtensible &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getOwnPropertyDescriptor
                    <pre><code>(function (){
  return typeof Object.getOwnPropertyDescriptor &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getOwnPropertyNames
                    <pre><code>(function (){
  return typeof Object.getOwnPropertyNames &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Array methods

              <ul>
                <li>
                  SUCCESS - Array.isArray
                    <pre><code>(function (){
  return typeof Array.isArray &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.indexOf
                    <pre><code>(function (){
  return typeof Array.prototype.indexOf &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.lastIndexOf
                    <pre><code>(function (){
  return typeof Array.prototype.lastIndexOf &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.every
                    <pre><code>(function (){
  return typeof Array.prototype.every &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.some
                    <pre><code>(function (){
  return typeof Array.prototype.some &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.forEach
                    <pre><code>(function (){
  return typeof Array.prototype.forEach &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.map
                    <pre><code>(function (){
  return typeof Array.prototype.map &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.filter
                    <pre><code>(function (){
  return typeof Array.prototype.filter &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.reduce
                    <pre><code>(function (){
  return typeof Array.prototype.reduce &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.reduceRight
                    <pre><code>(function (){
  return typeof Array.prototype.reduceRight &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - String properties and methods

              <ul>
                <li>
                  SUCCESS - Property access on strings
                    <pre><code>(function (){
  return &quot;foobar&quot;[3] &#x3D;&#x3D;&#x3D; &quot;b&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.trim
                    <pre><code>(function (){
  return typeof String.prototype.trim &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Date methods

              <ul>
                <li>
                  SUCCESS - Date.prototype.toISOString
                    <pre><code>(function (){
  return typeof Date.prototype.toISOString &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Date.now
                    <pre><code>(function (){
  return typeof Date.now &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Date.prototype.toJSON
                    <pre><code>(function (){
  try {
    return Date.prototype.toJSON.call(new Date(NaN)) &#x3D;&#x3D;&#x3D; null;
  } catch (e) {
    return false;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Function.prototype.bind
              <pre><code>(function (){
  return typeof Function.prototype.bind &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
          <li>
            SUCCESS - JSON
              <pre><code>(function (){
  return typeof JSON &#x3D;&#x3D; &#x27;object&#x27;;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
          <li>
            SUCCESS - Immutable globals

              <ul>
                <li>
                  SUCCESS - undefined
                    <pre><code>(function (){
  undefined &#x3D; 12345;
  var result &#x3D; typeof undefined &#x3D;&#x3D; &#x27;undefined&#x27;;
  undefined &#x3D; void 0;
  return result;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - NaN
                    <pre><code>(function (){
  NaN &#x3D; false;
  var result &#x3D; typeof NaN &#x3D;&#x3D; &#x27;number&#x27;;
  NaN &#x3D; Math.sqrt(-1);
  return result;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Infinity
                    <pre><code>(function (){
  Infinity &#x3D; false;
  var result &#x3D; typeof Infinity &#x3D;&#x3D; &#x27;number&#x27;;
  Infinity &#x3D; 1/0;
  return result;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Miscellaneous

              <ul>
                <li>
                  FAIL - Array.prototype.sort: compareFn must be function or undefined
                    <pre><code>(function (){
  try {
    [1,2].sort(null);
    return false;
  } catch (enull) {}
  try {
    [1,2].sort(true);
    return false;
  } catch (etrue) {}
  try {
    [1,2].sort({});
    return false;
  } catch (eobj) {}
  try {
    [1,2].sort([]);
    return false;
  } catch (earr) {}
  try {
    [1,2].sort(/a/g);
    return false;
  } catch (eregex) {}
  return true;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.sort: compareFn may be explicit undefined
                    <pre><code>(function (){
  try {
    var arr &#x3D; [2, 1];
    return arr.sort(undefined) &#x3D;&#x3D;&#x3D; arr &amp;&amp; arr[0] &#x3D;&#x3D;&#x3D; 1 &amp;&amp; arr[1] &#x3D;&#x3D;&#x3D; 2;
  } catch (e) {
    return false;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Date.parse produces NaN for invalid dates
                    <pre><code>(function (){
  var brokenOnFirefox &#x3D; !isNaN(Date.parse(&#x27;2012-04-04T24:00:00.500Z&#x27;));
  var brokenOnIE10 &#x3D; !isNaN(Date.parse(&#x27;2012-12-31T24:01:00.000Z&#x27;));
  var brokenOnChrome &#x3D; !isNaN(Date.parse(&#x27;2011-02-29T12:00:00.000Z&#x27;));
  return !brokenOnFirefox &amp;&amp; !brokenOnIE10 &amp;&amp; !brokenOnChrome;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Function.prototype.apply permits array-likes
                    <pre><code>(function (){
  return (function(a,b) { return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2; }).apply({}, {0:1, 1:2, length:2});
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - parseInt ignores leading zeros
                    <pre><code>(function (){
  return parseInt(&#x27;010&#x27;) &#x3D;&#x3D;&#x3D; 10;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Function &quot;prototype&quot; property is non-enumerable
                    <pre><code>(function (){
  return !Function().propertyIsEnumerable(&#x27;prototype&#x27;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Arguments toStringTag is &quot;Arguments&quot;
                    <pre><code>(function (){
  return (function(){ return Object.prototype.toString.call(arguments) &#x3D;&#x3D;&#x3D; &#x27;[object Arguments]&#x27;; }());
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Zero-width chars in identifiers
                    <pre><code>(function (){
  var _\u200c\u200d &#x3D; true;
  return _\u200c\u200d;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Unreserved words
                    <pre><code>(function (){
  var abstract, boolean, byte, char, double, final, float, goto, int, long,
    native, short, synchronized, transient, volatile;
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Enumerable properties can be shadowed by non-enumerables
                    <pre><code>(function (){
  var result &#x3D; true;
  Object.prototype.length &#x3D; 42;
  for (var i in Function) {
      if (i &#x3D;&#x3D; &#x27;length&#x27;) {
          result &#x3D; false;
      }
  }
  delete Object.prototype.length;
  return result;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Thrown functions have proper &quot;this&quot; values
                    <pre><code>(function (){
  try {
    throw function() { return !(&#x27;a&#x27; in this); };
  }
  catch(e) {
    var a &#x3D; true;
    return e();
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Strict mode
              <pre><code>(function (){
  &quot;use strict&quot;;
  return !this;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
      </ul>

      <h2>ES6 Features</h2>
      <ul>
          <li>
            FAIL - proper tail calls (tail call optimisation)

              <ul>
                <li>
                  FAIL - direct recursion
                    <pre><code>(function (){
  &quot;use strict&quot;;
  return (function f(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;foo&quot;;
    }
    return f(n - 1);
  }(1e6)) &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: RangeError: Maximum call stack size exceeded</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - mutual recursion
                    <pre><code>(function (){
  &quot;use strict&quot;;
  function f(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;foo&quot;;
    }
    return g(n - 1);
  }
  function g(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;bar&quot;;
    }
    return f(n - 1);
  }
  return f(1e6) &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; f(1e6+1) &#x3D;&#x3D;&#x3D; &quot;bar&quot;;
})()</code></pre>
                    <span>Result: RangeError: Maximum call stack size exceeded</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - default function parameters

              <ul>
                <li>
                  FAIL - basic functionality
                    <pre><code>(function (){
  return (function (a &#x3D; 1, b &#x3D; 2) { return a &#x3D;&#x3D;&#x3D; 3 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2; }(3));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - explicit undefined defers to the default
                    <pre><code>(function (){
  return (function (a &#x3D; 1, b &#x3D; 2) { return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 3; }(undefined, 3));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults can refer to previous params
                    <pre><code>(function (){
  return (function (a, b &#x3D; a) { return b &#x3D;&#x3D;&#x3D; 5; }(5));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - arguments object interaction
                    <pre><code>(function (){
  return (function (a &#x3D; &quot;baz&quot;, b &#x3D; &quot;qux&quot;, c &#x3D; &quot;quux&quot;) {
    a &#x3D; &quot;corge&quot;;
    // The arguments object is not mapped to the
    // parameters, even outside of strict mode.
    return arguments.length &#x3D;&#x3D;&#x3D; 2
      &amp;&amp; arguments[0] &#x3D;&#x3D;&#x3D; &quot;foo&quot;
      &amp;&amp; arguments[1] &#x3D;&#x3D;&#x3D; &quot;bar&quot;;
  }(&quot;foo&quot;, &quot;bar&quot;));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - temporal dead zone
                    <pre><code>(function (){
  return (function(x &#x3D; 1) {
    try {
      eval(&quot;(function(a&#x3D;a){}())&quot;);
      return false;
    } catch(e) {}
    try {
      eval(&quot;(function(a&#x3D;b,b){}())&quot;);
      return false;
    } catch(e) {}
    return true;
  }());
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - separate scope
                    <pre><code>(function (){
  return (function(a&#x3D;function(){
    return typeof b &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;;
  }){
    var b &#x3D; 1;
    return a();
  }());
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - new Function() support
                    <pre><code>(function (){
  return new Function(&quot;a &#x3D; 1&quot;, &quot;b &#x3D; 2&quot;,
    &quot;return a &#x3D;&#x3D;&#x3D; 3 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2;&quot;
  )(3);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token &#x3D;</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - rest parameters

              <ul>
                <li>
                  FAIL - basic functionality
                    <pre><code>(function (){
  return (function (foo, ...args) {
    return args instanceof Array &amp;&amp; args + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;bar,baz&quot;;
  }(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - function &#x27;length&#x27; property
                    <pre><code>(function (){
  return function(a, ...b){}.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; function(...c){}.length &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - arguments object interaction
                    <pre><code>(function (){
  return (function (foo, ...args) {
    foo &#x3D; &quot;qux&quot;;
    // The arguments object is not mapped to the
    // parameters, even outside of strict mode.
    return arguments.length &#x3D;&#x3D;&#x3D; 3
      &amp;&amp; arguments[0] &#x3D;&#x3D;&#x3D; &quot;foo&quot;
      &amp;&amp; arguments[1] &#x3D;&#x3D;&#x3D; &quot;bar&quot;
      &amp;&amp; arguments[2] &#x3D;&#x3D;&#x3D; &quot;baz&quot;;
  }(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - can&#x27;t be used in setters
                    <pre><code>(function (){
  return (function (...args) {
    try {
      eval(&quot;({set e(...args){}})&quot;);
    } catch(e) {
      return true;
    }
  }());
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - new Function() support
                    <pre><code>(function (){
  return new Function(&quot;a&quot;, &quot;...b&quot;,
    &quot;return b instanceof Array &amp;&amp; a+b &#x3D;&#x3D;&#x3D; &#x27;foobar,baz&#x27;;&quot;
  )(&#x27;foo&#x27;,&#x27;bar&#x27;,&#x27;baz&#x27;);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - spread (...) operator

              <ul>
                <li>
                  FAIL - with arrays, in function calls
                    <pre><code>(function (){
  return Math.max(...[1, 2, 3]) &#x3D;&#x3D;&#x3D; 3
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with arrays, in array literals
                    <pre><code>(function (){
  return [...[1, 2, 3]][2] &#x3D;&#x3D;&#x3D; 3;
 })()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with sparse arrays, in function calls
                    <pre><code>(function (){
  var a &#x3D; Array(...[,,]);
  return &quot;0&quot; in a &amp;&amp; &quot;1&quot; in a &amp;&amp; &#x27;&#x27; + a[0] + a[1] &#x3D;&#x3D;&#x3D; &quot;undefinedundefined&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with sparse arrays, in array literals
                    <pre><code>(function (){
  var a &#x3D; [...[,,]];
  return &quot;0&quot; in a &amp;&amp; &quot;1&quot; in a &amp;&amp; &#x27;&#x27; + a[0] + a[1] &#x3D;&#x3D;&#x3D; &quot;undefinedundefined&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with strings, in function calls
                    <pre><code>(function (){
  return Math.max(...&quot;1234&quot;) &#x3D;&#x3D;&#x3D; 4;
 })()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with strings, in array literals
                    <pre><code>(function (){
  return [&quot;a&quot;, ...&quot;bcd&quot;, &quot;e&quot;][3] &#x3D;&#x3D;&#x3D; &quot;d&quot;;
 })()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with astral plane strings, in function calls
                    <pre><code>(function (){
  return Array(...&quot;𠮷𠮶&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;𠮷&quot;;
 })()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with astral plane strings, in array literals
                    <pre><code>(function (){
  return [...&quot;𠮷𠮶&quot;][0] &#x3D;&#x3D;&#x3D; &quot;𠮷&quot;;
 })()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generator instances, in calls
                    <pre><code>(function (){
  var iterable &#x3D; (function*(){ yield 1; yield 2; yield 3; }());
  return Math.max(...iterable) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generator instances, in arrays
                    <pre><code>(function (){
  var iterable &#x3D; (function*(){ yield &quot;b&quot;; yield &quot;c&quot;; yield &quot;d&quot;; }());
  return [&quot;a&quot;, ...iterable, &quot;e&quot;][3] &#x3D;&#x3D;&#x3D; &quot;d&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables, in calls
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  return Math.max(...iterable) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables, in arrays
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);
  return [&quot;a&quot;, ...iterable, &quot;e&quot;][3] &#x3D;&#x3D;&#x3D; &quot;d&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of iterables, in calls
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  return Math.max(...Object.create(iterable)) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of iterables, in arrays
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([&quot;b&quot;, &quot;c&quot;, &quot;d&quot;]);
  return [&quot;a&quot;, ...Object.create(iterable), &quot;e&quot;][3] &#x3D;&#x3D;&#x3D; &quot;d&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - spreading non-iterables is a runtime error
                    <pre><code>(function (){
  try {
    Math.max(...2);
  } catch(e) {
    return Math.max(...[1, 2, 3]) &#x3D;&#x3D;&#x3D; 3;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token ...</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - object literal extensions

              <ul>
                <li>
                  SUCCESS - computed properties
                    <pre><code>(function (){
  var x &#x3D; &#x27;y&#x27;;
  return ({ [x]: 1 }).y &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand properties
                    <pre><code>(function (){
  var a &#x3D; 7, b &#x3D; 8, c &#x3D; {a,b};
  return c.a &#x3D;&#x3D;&#x3D; 7 &amp;&amp; c.b &#x3D;&#x3D;&#x3D; 8;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand methods
                    <pre><code>(function (){
  return ({ y() { return 2; } }).y() &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - string-keyed shorthand methods
                    <pre><code>(function (){
  return ({ &quot;foo bar&quot;() { return 4; } })[&quot;foo bar&quot;]() &#x3D;&#x3D;&#x3D; 4;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed shorthand methods
                    <pre><code>(function (){
  var x &#x3D; &#x27;y&#x27;;
  return ({ [x](){ return 1 } }).y() &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed accessors
                    <pre><code>(function (){
  var x &#x3D; &#x27;y&#x27;,
      valueSet,
      obj &#x3D; {
        get [x] () { return 1 },
        set [x] (value) { valueSet &#x3D; value }
      };
  obj.y &#x3D; &#x27;foo&#x27;;
  return obj.y &#x3D;&#x3D;&#x3D; 1 &amp;&amp; valueSet &#x3D;&#x3D;&#x3D; &#x27;foo&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - for..of loops

              <ul>
                <li>
                  SUCCESS - with arrays
                    <pre><code>(function (){
  var arr &#x3D; [5];
  for (var item of arr)
    return item &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - with sparse arrays
                    <pre><code>(function (){
  var arr &#x3D; [,,];
  var count &#x3D; 0;
  for (var item of arr)
    count +&#x3D; (item &#x3D;&#x3D;&#x3D; undefined);
  return count &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - with strings
                    <pre><code>(function (){
  var str &#x3D; &quot;&quot;;
  for (var item of &quot;foo&quot;)
    str +&#x3D; item;
  return str &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - with astral plane strings
                    <pre><code>(function (){
  var str &#x3D; &quot;&quot;;
  for (var item of &quot;𠮷𠮶&quot;)
    str +&#x3D; item + &quot; &quot;;
  return str &#x3D;&#x3D;&#x3D; &quot;𠮷 𠮶 &quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - with generator instances
                    <pre><code>(function (){
  var result &#x3D; &quot;&quot;;
  var iterable &#x3D; (function*(){ yield 1; yield 2; yield 3; }());
  for (var item of iterable) {
    result +&#x3D; item;
  }
  return result &#x3D;&#x3D;&#x3D; &quot;123&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables
                    <pre><code>(function (){
  var result &#x3D; &quot;&quot;;
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  for (var item of iterable) {
    result +&#x3D; item;
  }
  return result &#x3D;&#x3D;&#x3D; &quot;123&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of generic iterables
                    <pre><code>(function (){
  var result &#x3D; &quot;&quot;;
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  for (var item of Object.create(iterable)) {
    result +&#x3D; item;
  }
  return result &#x3D;&#x3D;&#x3D; &quot;123&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing, break
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; __createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  for (var it of iter) break;
  return closed;
})()</code></pre>
                    <span>Result: ReferenceError: __createIterableObject is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing, throw
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; __createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  try {
    for (var it of iter) throw 0;
  } catch(e){}
  return closed;
})()</code></pre>
                    <span>Result: ReferenceError: __createIterableObject is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - octal and binary literals

              <ul>
                <li>
                  SUCCESS - octal literals
                    <pre><code>(function (){
  return 0o10 &#x3D;&#x3D;&#x3D; 8 &amp;&amp; 0O10 &#x3D;&#x3D;&#x3D; 8;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - binary literals
                    <pre><code>(function (){
  return 0b10 &#x3D;&#x3D;&#x3D; 2 &amp;&amp; 0B10 &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - octal supported by Number()
                    <pre><code>(function (){
  return Number(&#x27;0o1&#x27;) &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - binary supported by Number()
                    <pre><code>(function (){
  return Number(&#x27;0b1&#x27;) &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - template literals

              <ul>
                <li>
                  FAIL - basic functionality
                    <pre><code>(function (){
  var a &#x3D; &quot;ba&quot;, b &#x3D; &quot;QUX&quot;;
  return &#x60;foo bar
  ${a + &quot;z&quot;} ${b.toLowerCase()}&#x60; &#x3D;&#x3D;&#x3D; &quot;foo bar\nbaz qux&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - toString conversion
                    <pre><code>(function (){
  var a &#x3D; {
    toString: function() { return &quot;foo&quot;; },
    valueOf: function() { return &quot;bar&quot;; },
  };
  return &#x60;${a}&#x60; &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - tagged template literals
                    <pre><code>(function (){
  var called &#x3D; false;
  function fn(parts, a, b) {
    called &#x3D; true;
    return parts instanceof Array &amp;&amp;
      parts[0]     &#x3D;&#x3D;&#x3D; &quot;foo&quot;      &amp;&amp;
      parts[1]     &#x3D;&#x3D;&#x3D; &quot;bar\n&quot;    &amp;&amp;
      parts.raw[0] &#x3D;&#x3D;&#x3D; &quot;foo&quot;      &amp;&amp;
      parts.raw[1] &#x3D;&#x3D;&#x3D; &quot;bar\\n&quot;   &amp;&amp;
      a &#x3D;&#x3D;&#x3D; 123                   &amp;&amp;
      b &#x3D;&#x3D;&#x3D; 456;
  }
  return fn &#x60;foo${123}bar\n${456}&#x60; &amp;&amp; called;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - passed array is frozen
                    <pre><code>(function (){
  return (function(parts) {
    return Object.isFrozen(parts) &amp;&amp; Object.isFrozen(parts.raw);
  }) &#x60;foo${0}bar${0}baz&#x60;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - line break normalisation
                    <pre><code>(function (){
  var cr   &#x3D; eval(&quot;&#x60;x&quot; + String.fromCharCode(13)    + &quot;y&#x60;&quot;);
  var lf   &#x3D; eval(&quot;&#x60;x&quot; + String.fromCharCode(10)    + &quot;y&#x60;&quot;);
  var crlf &#x3D; eval(&quot;&#x60;x&quot; + String.fromCharCode(13,10) + &quot;y&#x60;&quot;);

  return cr.length &#x3D;&#x3D;&#x3D; 3 &amp;&amp; lf.length &#x3D;&#x3D;&#x3D; 3 &amp;&amp; crlf.length &#x3D;&#x3D;&#x3D; 3
    &amp;&amp; cr[1] &#x3D;&#x3D;&#x3D; lf[1] &amp;&amp; lf[1] &#x3D;&#x3D;&#x3D; crlf[1] &amp;&amp; crlf[1] &#x3D;&#x3D;&#x3D; &#x27;\n&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - RegExp &quot;y&quot; and &quot;u&quot; flags

              <ul>
                <li>
                  FAIL - &quot;y&quot; flag
                    <pre><code>(function (){
  var re &#x3D; new RegExp(&#x27;\\w&#x27;, &#x27;y&#x27;);
  re.exec(&#x27;xy&#x27;);
  return (re.exec(&#x27;xy&#x27;)[0] &#x3D;&#x3D;&#x3D; &#x27;y&#x27;);
})()</code></pre>
                    <span>Result: SyntaxError: Invalid flags supplied to RegExp constructor &#x27;y&#x27;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;y&quot; flag, lastIndex
                    <pre><code>(function (){
  var re &#x3D; new RegExp(&#x27;yy&#x27;, &#x27;y&#x27;);
  re.lastIndex &#x3D; 3;
  var result &#x3D; re.exec(&#x27;xxxyyxx&#x27;)[0];
  return result &#x3D;&#x3D;&#x3D; &#x27;yy&#x27; &amp;&amp; re.lastIndex &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: SyntaxError: Invalid flags supplied to RegExp constructor &#x27;y&#x27;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;u&quot; flag
                    <pre><code>(function (){
  return &quot;𠮷&quot;.match(/^.$/u)[0].length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: SyntaxError: Invalid flags supplied to RegExp constructor &#x27;u&#x27;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;u&quot; flag, Unicode code point escapes
                    <pre><code>(function (){
  return &quot;𝌆&quot;.match(/\u{1d306}/u)[0].length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: SyntaxError: Invalid flags supplied to RegExp constructor &#x27;u&#x27;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;u&quot; flag, case folding
                    <pre><code>(function (){
  return &quot;ſ&quot;.match(/S/iu) &amp;&amp; &quot;ſ&quot;.match(/\w/iu) &amp;&amp; &quot;ſ&quot;.match(/\W/iu)
   &amp;&amp; &quot;S&quot;.match(/ſ/iu) &amp;&amp; &quot;S&quot;.match(/\w/iu) &amp;&amp; &quot;S&quot;.match(/\W/iu);
})()</code></pre>
                    <span>Result: SyntaxError: Invalid flags supplied to RegExp constructor &#x27;iu&#x27;</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - destructuring, declarations

              <ul>
                <li>
                  FAIL - with arrays
                    <pre><code>(function (){
  var [a, , [b], c] &#x3D; [5, null, [6]];
  return a &#x3D;&#x3D;&#x3D; 5 &amp;&amp; b &#x3D;&#x3D;&#x3D; 6 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with sparse arrays
                    <pre><code>(function (){
  var [a, , b] &#x3D; [,,,];
  return a &#x3D;&#x3D;&#x3D; undefined &amp;&amp; b &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with strings
                    <pre><code>(function (){
  var [a, b, c] &#x3D; &quot;ab&quot;;
  return a &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D; &quot;b&quot; &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with astral plane strings
                    <pre><code>(function (){
  var [c] &#x3D; &quot;𠮷𠮶&quot;;
  return c &#x3D;&#x3D;&#x3D; &quot;𠮷&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generator instances
                    <pre><code>(function (){
  var [a, b, c] &#x3D; (function*(){ yield 1; yield 2; }());
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables
                    <pre><code>(function (){
  var [a, b, c] &#x3D; global.__createIterableObject([1, 2]);
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of generic iterables
                    <pre><code>(function (){
  var [a, b, c] &#x3D; Object.create(global.__createIterableObject([1, 2]));
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  var [a, b] &#x3D; iter;
  return closed;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in iterable patterns
                    <pre><code>(function (){
  var [a,] &#x3D; [1];
  return a &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with objects
                    <pre><code>(function (){
  var {c, x:d, e} &#x3D; {c:7, x:8};
  return c &#x3D;&#x3D;&#x3D; 7 &amp;&amp; d &#x3D;&#x3D;&#x3D; 8 &amp;&amp; e &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object destructuring with primitives
                    <pre><code>(function (){
  var {toFixed} &#x3D; 2;
  var {slice} &#x3D; &#x27;&#x27;;
  return toFixed &#x3D;&#x3D;&#x3D; Number.prototype.toFixed
    &amp;&amp; slice &#x3D;&#x3D;&#x3D; String.prototype.slice;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in object patterns
                    <pre><code>(function (){
  var {a,} &#x3D; {a:1};
  return a &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - throws on null and undefined
                    <pre><code>(function (){
  try {
    var {a} &#x3D; null;
    return false;
  } catch(e) {}
  try {
    var {b} &#x3D; undefined;
    return false;
  } catch(e) {}
  return true;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - computed properties
                    <pre><code>(function (){
  var qux &#x3D; &quot;corge&quot;;
  var { [qux]: grault } &#x3D; { corge: &quot;garply&quot; };
  return grault &#x3D;&#x3D;&#x3D; &quot;garply&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - multiples in a single var statement
                    <pre><code>(function (){
  var [a,b] &#x3D; [5,6], {c,d} &#x3D; {c:7,d:8};
  return a &#x3D;&#x3D;&#x3D; 5 &amp;&amp; b &#x3D;&#x3D;&#x3D; 6 &amp;&amp; c &#x3D;&#x3D;&#x3D; 7 &amp;&amp; d &#x3D;&#x3D;&#x3D; 8;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - nested
                    <pre><code>(function (){
  var [e, {x:f, g}] &#x3D; [9, {x:10}];
  var {h, x:[i]} &#x3D; {h:11, x:[12]};
  return e &#x3D;&#x3D;&#x3D; 9 &amp;&amp; f &#x3D;&#x3D;&#x3D; 10 &amp;&amp; g &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; h &#x3D;&#x3D;&#x3D; 11 &amp;&amp; i &#x3D;&#x3D;&#x3D; 12;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - in for-in loop heads
                    <pre><code>(function (){
  for(var [i, j, k] in { qux: 1 }) {
    return i &#x3D;&#x3D;&#x3D; &quot;q&quot; &amp;&amp; j &#x3D;&#x3D;&#x3D; &quot;u&quot; &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;x&quot;;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - in for-of loop heads
                    <pre><code>(function (){
  for(var [i, j, k] of [[1,2,3]]) {
    return i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 2 &amp;&amp; k &#x3D;&#x3D;&#x3D; 3;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - in catch heads
                    <pre><code>(function (){
  try {
    throw [1,2];
  } catch([i,j]) {
    try {
      throw { k: 3, l: 4 };
    } catch({k, l}) {
      return i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 2 &amp;&amp; k &#x3D;&#x3D;&#x3D; 3 &amp;&amp; l &#x3D;&#x3D;&#x3D; 4;
    }
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - rest
                    <pre><code>(function (){
  var [a, ...b] &#x3D; [3, 4, 5];
  var [c, ...d] &#x3D; [6];
  return a &#x3D;&#x3D;&#x3D; 3 &amp;&amp; b instanceof Array &amp;&amp; (b + &quot;&quot;) &#x3D;&#x3D;&#x3D; &quot;4,5&quot; &amp;&amp;
     c &#x3D;&#x3D;&#x3D; 6 &amp;&amp; d instanceof Array &amp;&amp; d.length &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults
                    <pre><code>(function (){
  var {a &#x3D; 1, b &#x3D; 0, z:c &#x3D; 3} &#x3D; {b:2, z:undefined};
  var [d &#x3D; 0, e &#x3D; 5, f &#x3D; 6] &#x3D; [4,,undefined];
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3
    &amp;&amp; d &#x3D;&#x3D;&#x3D; 4 &amp;&amp; e &#x3D;&#x3D;&#x3D; 5 &amp;&amp; f &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults, let temporal dead zone
                    <pre><code>(function (){
  var {a, b &#x3D; 2} &#x3D; {a:1};
  try {
    eval(&quot;let {c &#x3D; c} &#x3D; {};&quot;);
    return false;
  } catch(e){}
  try {
    eval(&quot;let {c &#x3D; d, d} &#x3D; {d:1};&quot;);
    return false;
  } catch(e){}
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - destructuring, assignment

              <ul>
                <li>
                  FAIL - with arrays
                    <pre><code>(function (){
  var a,b,c;
  [a, , [b], c] &#x3D; [5, null, [6]];
  return a &#x3D;&#x3D;&#x3D; 5 &amp;&amp; b &#x3D;&#x3D;&#x3D; 6 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with sparse arrays
                    <pre><code>(function (){
  var a, b;
  [a, , b] &#x3D; [,,,];
  return a &#x3D;&#x3D;&#x3D; undefined &amp;&amp; b &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with strings
                    <pre><code>(function (){
  var a,b,c;
  [a, b, c] &#x3D; &quot;ab&quot;;
  return a &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D; &quot;b&quot; &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with astral plane strings
                    <pre><code>(function (){
  var c;
  [c] &#x3D; &quot;𠮷𠮶&quot;;
  return c &#x3D;&#x3D;&#x3D; &quot;𠮷&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generator instances
                    <pre><code>(function (){
  var a,b,c;
  [a, b, c] &#x3D; (function*(){ yield 1; yield 2; }());
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables
                    <pre><code>(function (){
  var a,b,c;
  [a, b, c] &#x3D; global.__createIterableObject([1, 2]);
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of generic iterables
                    <pre><code>(function (){
  var a,b,c;
  [a, b, c] &#x3D; Object.create(global.__createIterableObject([1, 2]));
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  var a,b;
  [a, b] &#x3D; iter;
  return closed;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterable destructuring expression
                    <pre><code>(function (){
  var a, b, iterable &#x3D; [1,2];
  return ([a, b] &#x3D; iterable) &#x3D;&#x3D;&#x3D; iterable;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - chained iterable destructuring
                    <pre><code>(function (){
  var a,b,c,d;
  [a,b] &#x3D; [c,d] &#x3D; [1,2];
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 1 &amp;&amp; d &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in iterable patterns
                    <pre><code>(function (){
  var a;
  [a,] &#x3D; [1];
  return a &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with objects
                    <pre><code>(function (){
  var c,d,e;
  ({c, x:d, e} &#x3D; {c:7, x:8});
  return c &#x3D;&#x3D;&#x3D; 7 &amp;&amp; d &#x3D;&#x3D;&#x3D; 8 &amp;&amp; e &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object destructuring with primitives
                    <pre><code>(function (){
  var toFixed, slice;
  ({toFixed} &#x3D; 2);
  ({slice} &#x3D; &#x27;&#x27;);
  return toFixed &#x3D;&#x3D;&#x3D; Number.prototype.toFixed
    &amp;&amp; slice &#x3D;&#x3D;&#x3D; String.prototype.slice;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in object patterns
                    <pre><code>(function (){
  var a;
  ({a,} &#x3D; {a:1});
  return a &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object destructuring expression
                    <pre><code>(function (){
  var a, b, obj &#x3D; { a:1, b:2 };
  return ({a,b} &#x3D; obj) &#x3D;&#x3D;&#x3D; obj;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - parenthesised left-hand-side is a syntax error
                    <pre><code>(function (){
  var a, b;
  ({a,b} &#x3D; {a:1,b:2});
  try {
    eval(&quot;({a,b}) &#x3D; {a:3,b:4};&quot;);
  }
  catch(e) {
    return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2;
  }
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - chained object destructuring
                    <pre><code>(function (){
  var a,b,c,d;
  ({a,b} &#x3D; {c,d} &#x3D; {a:1,b:2,c:3,d:4});
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3 &amp;&amp; d &#x3D;&#x3D;&#x3D; 4;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - throws on null and undefined
                    <pre><code>(function (){
  var a,b;
  try {
    ({a} &#x3D; null);
    return false;
  } catch(e) {}
  try {
    ({b} &#x3D; undefined);
    return false;
  } catch(e) {}
  return true;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - computed properties
                    <pre><code>(function (){
  var grault, qux &#x3D; &quot;corge&quot;;
  ({ [qux]: grault } &#x3D; { corge: &quot;garply&quot; });
  return grault &#x3D;&#x3D;&#x3D; &quot;garply&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - nested
                    <pre><code>(function (){
  var e,f,g,h,i;
  [e, {x:f, g}] &#x3D; [9, {x:10}];
  ({h, x:[i]} &#x3D; {h:11, x:[12]});
  return e &#x3D;&#x3D;&#x3D; 9 &amp;&amp; f &#x3D;&#x3D;&#x3D; 10 &amp;&amp; g &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; h &#x3D;&#x3D;&#x3D; 11 &amp;&amp; i &#x3D;&#x3D;&#x3D; 12;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - rest
                    <pre><code>(function (){
  var a,b,c,d;
  [a, ...b] &#x3D; [3, 4, 5];
  [c, ...d] &#x3D; [6];
  return a &#x3D;&#x3D;&#x3D; 3 &amp;&amp; b instanceof Array &amp;&amp; (b + &quot;&quot;) &#x3D;&#x3D;&#x3D; &quot;4,5&quot; &amp;&amp;
     c &#x3D;&#x3D;&#x3D; 6 &amp;&amp; d instanceof Array &amp;&amp; d.length &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - nested rest
                    <pre><code>(function (){
  var a &#x3D; [1, 2, 3], first, last;
  [first, ...[a[2], last]] &#x3D; a;
  return first &#x3D;&#x3D;&#x3D; 1 &amp;&amp; last &#x3D;&#x3D;&#x3D; 3 &amp;&amp; (a + &quot;&quot;) &#x3D;&#x3D;&#x3D; &quot;1,2,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - empty patterns
                    <pre><code>(function (){
  [] &#x3D; [1,2];
  ({} &#x3D; {a:1,b:2});
  return true;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults
                    <pre><code>(function (){
  var a,b,c,d,e,f;
  ({a &#x3D; 1, b &#x3D; 0, z:c &#x3D; 3} &#x3D; {b:2, z:undefined});
  [d &#x3D; 0, e &#x3D; 5, f &#x3D; 6] &#x3D; [4,,undefined];
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3
    &amp;&amp; d &#x3D;&#x3D;&#x3D; 4 &amp;&amp; e &#x3D;&#x3D;&#x3D; 5 &amp;&amp; f &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
                    <span>Result: ReferenceError: Invalid left-hand side in assignment</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - destructuring, parameters

              <ul>
                <li>
                  FAIL - with arrays
                    <pre><code>(function (){
  return function([a, , [b], c]) {
    return a &#x3D;&#x3D;&#x3D; 5 &amp;&amp; b &#x3D;&#x3D;&#x3D; 6 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
  }([5, null, [6]]);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with sparse arrays
                    <pre><code>(function (){
  return function([a, , b]) {
    return a &#x3D;&#x3D;&#x3D; undefined &amp;&amp; b &#x3D;&#x3D;&#x3D; undefined;
  }([,,,]);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with strings
                    <pre><code>(function (){
  return function([a, b, c]) {
    return a &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; b &#x3D;&#x3D;&#x3D; &quot;b&quot; &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
  }(&quot;ab&quot;);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with astral plane strings
                    <pre><code>(function (){
  return function([c]) {
    return c &#x3D;&#x3D;&#x3D; &quot;𠮷&quot;;
  }(&quot;𠮷𠮶&quot;);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generator instances
                    <pre><code>(function (){
  return function([a, b, c]) {
    return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
  }(function*(){ yield 1; yield 2; }());
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with generic iterables
                    <pre><code>(function (){
  return function([a, b, c]) {
    return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
  }(global.__createIterableObject([1, 2]));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with instances of generic iterables
                    <pre><code>(function (){
  return function([a, b, c]) {
    return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; undefined;
  }(Object.create(global.__createIterableObject([1, 2])));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  (function([a,b]) {}(iter));
  return closed;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in iterable patterns
                    <pre><code>(function (){
  return function([a,]) {
    return a &#x3D;&#x3D;&#x3D; 1;
  }([1]);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - with objects
                    <pre><code>(function (){
  return function({c, x:d, e}) {
    return c &#x3D;&#x3D;&#x3D; 7 &amp;&amp; d &#x3D;&#x3D;&#x3D; 8 &amp;&amp; e &#x3D;&#x3D;&#x3D; undefined;
  }({c:7, x:8});
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object destructuring with primitives
                    <pre><code>(function (){
  return function({toFixed}, {slice}) {
    return toFixed &#x3D;&#x3D;&#x3D; Number.prototype.toFixed
      &amp;&amp; slice &#x3D;&#x3D;&#x3D; String.prototype.slice;
  }(2,&#x27;&#x27;);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - trailing commas in object patterns
                    <pre><code>(function (){
  return function({a,}) {
    return a &#x3D;&#x3D;&#x3D; 1;
  }({a:1});
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - throws on null and undefined
                    <pre><code>(function (){
  try {
    (function({a}){}(null));
    return false;
  } catch(e) {}
  try {
    (function({b}){}(undefined));
    return false;
  } catch(e) {}
  return true;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - computed properties
                    <pre><code>(function (){
  var qux &#x3D; &quot;corge&quot;;
  return function({ [qux]: grault }) {
    return grault &#x3D;&#x3D;&#x3D; &quot;garply&quot;;
  }({ corge: &quot;garply&quot; });
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - nested
                    <pre><code>(function (){
  return function([e, {x:f, g}], {h, x:[i]}) {
    return e &#x3D;&#x3D;&#x3D; 9 &amp;&amp; f &#x3D;&#x3D;&#x3D; 10 &amp;&amp; g &#x3D;&#x3D;&#x3D; undefined
      &amp;&amp; h &#x3D;&#x3D;&#x3D; 11 &amp;&amp; i &#x3D;&#x3D;&#x3D; 12;
  }([9, {x:10}],{h:11, x:[12]});
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &#x27;arguments&#x27; interaction
                    <pre><code>(function (){
  return (function({a, x:b, y:e}, [c, d]) {
    return arguments[0].a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; arguments[0].x &#x3D;&#x3D;&#x3D; 2
      &amp;&amp; !(&quot;y&quot; in arguments[0]) &amp;&amp; arguments[1] + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,4&quot;;
  }({a:1, x:2}, [3, 4]));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - new Function() support
                    <pre><code>(function (){
  return new Function(&quot;{a, x:b, y:e}&quot;,&quot;[c, d]&quot;,
    &quot;return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3 &amp;&amp; &quot;
    + &quot;d &#x3D;&#x3D;&#x3D; 4 &amp;&amp; e &#x3D;&#x3D;&#x3D; undefined;&quot;
  )({a:1, x:2}, [3, 4]);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - in parameters, function &#x27;length&#x27; property
                    <pre><code>(function (){
  return function({a, b}, [c, d]){}.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - rest
                    <pre><code>(function (){
  return function([a, ...b], [c, ...d]) {
    return a &#x3D;&#x3D;&#x3D; 3 &amp;&amp; b instanceof Array &amp;&amp; (b + &quot;&quot;) &#x3D;&#x3D;&#x3D; &quot;4,5&quot; &amp;&amp;
       c &#x3D;&#x3D;&#x3D; 6 &amp;&amp; d instanceof Array &amp;&amp; d.length &#x3D;&#x3D;&#x3D; 0;
  }([3, 4, 5], [6]);
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - empty patterns
                    <pre><code>(function (){
  return function ([],{}){
    return arguments[0] + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,4&quot; &amp;&amp; arguments[1].x &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
  }([3,4],{x:&quot;foo&quot;});
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token [</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults
                    <pre><code>(function (){
  return (function({a &#x3D; 1, b &#x3D; 0, c &#x3D; 3, x:d &#x3D; 0, y:e &#x3D; 5},
      [f &#x3D; 6, g &#x3D; 0, h &#x3D; 8]) {
    return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3 &amp;&amp; d &#x3D;&#x3D;&#x3D; 4 &amp;&amp;
      e &#x3D;&#x3D;&#x3D; 5 &amp;&amp; f &#x3D;&#x3D;&#x3D; 6 &amp;&amp; g &#x3D;&#x3D;&#x3D; 7 &amp;&amp; h &#x3D;&#x3D;&#x3D; 8;
  }({b:2, c:undefined, x:4},[, 7, undefined]));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults, separate scope
                    <pre><code>(function (){
  return (function({a&#x3D;function(){
    return typeof b &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;;
  }}){
    var b &#x3D; 1;
    return a();
  }({}));
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - defaults, new Function() support
                    <pre><code>(function (){
  return new Function(&quot;{a &#x3D; 1, b &#x3D; 0, c &#x3D; 3, x:d &#x3D; 0, y:e &#x3D; 5}&quot;,
    &quot;return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; c &#x3D;&#x3D;&#x3D; 3 &amp;&amp; d &#x3D;&#x3D;&#x3D; 4 &amp;&amp; e &#x3D;&#x3D;&#x3D; 5;&quot;
  )({b:2, c:undefined, x:4});
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token {</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Unicode code point escapes

              <ul>
                <li>
                  SUCCESS - in strings
                    <pre><code>(function (){
  return &#x27;\u{1d306}&#x27; &#x3D;&#x3D; &#x27;\ud834\udf06&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - in identifiers
                    <pre><code>(function (){
  var \u{102C0} &#x3D; { \u{102C0} : 2 };
  return \u{102C0}[&#x27;\ud800\udec0&#x27;] &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - new.target

              <ul>
                <li>
                  FAIL - in constructors
                    <pre><code>(function (){
  var passed &#x3D; false;
  new function f() {
    passed &#x3D; (new.target &#x3D;&#x3D;&#x3D; f);
  }();
  (function() {
    passed &amp;&#x3D; (new.target &#x3D;&#x3D;&#x3D; undefined);
  }());
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - assignment is an early error
                    <pre><code>(function (){
  var passed &#x3D; false;
  new function f() {
    passed &#x3D; (new.target &#x3D;&#x3D;&#x3D; f);
  }();

  try {
    Function(&quot;new.target &#x3D; function(){};&quot;);
  } catch(e) {
    return passed;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - const

              <ul>
                <li>
                  SUCCESS - basic support
                    <pre><code>(function (){
  const foo &#x3D; 123;
  return (foo &#x3D;&#x3D;&#x3D; 123);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - is block-scoped
                    <pre><code>(function (){
  const bar &#x3D; 123;
  { const bar &#x3D; 456; }
  return bar &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: SyntaxError: Identifier &#x27;bar&#x27; has already been declared</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - cannot be in statements
                    <pre><code>(function (){
  const bar &#x3D; 1;
  try {
    Function(&quot;if(true) const baz &#x3D; 1;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - redefining a const is an error
                    <pre><code>(function (){
  const baz &#x3D; 1;
  try {
    Function(&quot;const foo &#x3D; 1; foo &#x3D; 2;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - for loop statement scope
                    <pre><code>(function (){
  const baz &#x3D; 1;
  for(const baz &#x3D; 0; false;) {}
  return baz &#x3D;&#x3D;&#x3D; 1;
  })()</code></pre>
                    <span>Result: SyntaxError: Identifier &#x27;baz&#x27; has already been declared</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - for-in loop iteration scope
                    <pre><code>(function (){
  var scopes &#x3D; [];
  for(const i in { a:1, b:1 }) {
    scopes.push(function(){ return i; });
  }
  return (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - for-of loop iteration scope
                    <pre><code>(function (){
  var scopes &#x3D; [];
  for(const i of [&#x27;a&#x27;,&#x27;b&#x27;]) {
    scopes.push(function(){ return i; });
  }
  return (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - temporal dead zone
                    <pre><code>(function (){
  var passed &#x3D; (function(){ try { qux; } catch(e) { return true; }}());
  function fn() { passed &amp;&#x3D; qux &#x3D;&#x3D;&#x3D; 456; }
  const qux &#x3D; 456;
  fn();
  return passed;
})()</code></pre>
                    <span>Result: 0</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - basic support (strict mode)
                    <pre><code>(function (){
  &quot;use strict&quot;;
  const foo &#x3D; 123;
  return (foo &#x3D;&#x3D;&#x3D; 123);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - is block-scoped (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  const bar &#x3D; 123;
  { const bar &#x3D; 456; }
  return bar &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - cannot be in statements (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  const bar &#x3D; 1;
  try {
    Function(&quot;&#x27;use strict&#x27;; if(true) const baz &#x3D; 1;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - redefining a const (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  const baz &#x3D; 1;
  try {
    Function(&quot;&#x27;use strict&#x27;; const foo &#x3D; 1; foo &#x3D; 2;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - for loop statement scope (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  const baz &#x3D; 1;
  for(const baz &#x3D; 0; false;) {}
  return baz &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - for-in loop iteration scope (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  var scopes &#x3D; [];
  for(const i in { a:1, b:1 }) {
    scopes.push(function(){ return i; });
  }
  return (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - for-of loop iteration scope (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  var scopes &#x3D; [];
  for(const i of [&#x27;a&#x27;,&#x27;b&#x27;]) {
    scopes.push(function(){ return i; });
  }
  return (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - temporal dead zone (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  var passed &#x3D; (function(){ try { qux; } catch(e) { return true; }}());
  function fn() { passed &amp;&#x3D; qux &#x3D;&#x3D;&#x3D; 456; }
  const qux &#x3D; 456;
  fn();
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - let

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  let foo &#x3D; 123;
  return (foo &#x3D;&#x3D;&#x3D; 123);
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - is block-scoped
                    <pre><code>(function (){
  let bar &#x3D; 123;
  { let bar &#x3D; 456; }
  return bar &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - cannot be in statements
                    <pre><code>(function (){
  let bar &#x3D; 1;
  try {
    Function(&quot;if(true) let baz &#x3D; 1;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - for loop statement scope
                    <pre><code>(function (){
  let baz &#x3D; 1;
  for(let baz &#x3D; 0; false;) {}
  return baz &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - temporal dead zone
                    <pre><code>(function (){
  var passed &#x3D; (function(){ try {  qux; } catch(e) { return true; }}());
  function fn() { passed &amp;&#x3D; qux &#x3D;&#x3D;&#x3D; 456; }
  let qux &#x3D; 456;
  fn();
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - for/for-in loop iteration scope
                    <pre><code>(function (){
  let scopes &#x3D; [];
  for(let i &#x3D; 0; i &lt; 2; i++) {
    scopes.push(function(){ return i; });
  }
  let passed &#x3D; (scopes[0]() &#x3D;&#x3D;&#x3D; 0 &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; 1);

  scopes &#x3D; [];
  for(let i in { a:1, b:1 }) {
    scopes.push(function(){ return i; });
  }
  passed &amp;&#x3D; (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - basic support (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  let foo &#x3D; 123;
  return (foo &#x3D;&#x3D;&#x3D; 123);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - is block-scoped (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  let bar &#x3D; 123;
  { let bar &#x3D; 456; }
  return bar &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - cannot be in statements (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  let bar &#x3D; 1;
  try {
    Function(&quot;&#x27;use strict&#x27;; if(true) let baz &#x3D; 1;&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - for loop statement scope (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  let baz &#x3D; 1;
  for(let baz &#x3D; 0; false;) {}
  return baz &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - temporal dead zone (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  var passed &#x3D; (function(){ try {  qux; } catch(e) { return true; }}());
  function fn() { passed &amp;&#x3D; qux &#x3D;&#x3D;&#x3D; 456; }
  let qux &#x3D; 456;
  fn();
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - for/for-in loop iteration scope (strict mode)
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  let scopes &#x3D; [];
  for(let i &#x3D; 0; i &lt; 2; i++) {
    scopes.push(function(){ return i; });
  }
  let passed &#x3D; (scopes[0]() &#x3D;&#x3D;&#x3D; 0 &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; 1);

  scopes &#x3D; [];
  for(let i in { a:1, b:1 }) {
    scopes.push(function(){ return i; });
  }
  passed &amp;&#x3D; (scopes[0]() &#x3D;&#x3D;&#x3D; &quot;a&quot; &amp;&amp; scopes[1]() &#x3D;&#x3D;&#x3D; &quot;b&quot;);
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - block-level function declaration
              <pre><code>(function (){
  &#x27;use strict&#x27;;
  function f() { return 1; }
  {
    function f() { return 2; }
  }
  return f() &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - arrow functions

              <ul>
                <li>
                  SUCCESS - 0 parameters
                    <pre><code>(function (){
  return (() &#x3D;&gt; 5)() &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - 1 parameter, no brackets
                    <pre><code>(function (){
  var b &#x3D; x &#x3D;&gt; x + &quot;foo&quot;;
  return (b(&quot;fee fie foe &quot;) &#x3D;&#x3D;&#x3D; &quot;fee fie foe foo&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - multiple parameters
                    <pre><code>(function (){
  var c &#x3D; (v, w, x, y, z) &#x3D;&gt; &quot;&quot; + v + w + x + y + z;
  return (c(6, 5, 4, 3, 2) &#x3D;&#x3D;&#x3D; &quot;65432&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - lexical &quot;this&quot; binding
                    <pre><code>(function (){
  var d &#x3D; { x : &quot;bar&quot;, y : function() { return z &#x3D;&gt; this.x + z; }}.y();
  var e &#x3D; { x : &quot;baz&quot;, y : d };
  return d(&quot;ley&quot;) &#x3D;&#x3D;&#x3D; &quot;barley&quot; &amp;&amp; e.y(&quot;ley&quot;) &#x3D;&#x3D;&#x3D; &quot;barley&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - &quot;this&quot; unchanged by call or apply
                    <pre><code>(function (){
  var d &#x3D; { x : &quot;foo&quot;, y : function() { return () &#x3D;&gt; this.x; }};
  var e &#x3D; { x : &quot;bar&quot; };
  return d.y().call(e) &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; d.y().apply(e) &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - can&#x27;t be bound, can be curried
                    <pre><code>(function (){
  var d &#x3D; { x : &quot;bar&quot;, y : function() { return z &#x3D;&gt; this.x + z; }};
  var e &#x3D; { x : &quot;baz&quot; };
  return d.y().bind(e, &quot;ley&quot;)() &#x3D;&#x3D;&#x3D; &quot;barley&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - lexical &quot;arguments&quot; binding
                    <pre><code>(function (){
  var f &#x3D; (function() { return z &#x3D;&gt; arguments[0]; }(5));
  return f(6) &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - no line break between params and &lt;code&gt;&#x3D;&gt;&lt;/code&gt;
                    <pre><code>(function (){
  return (() &#x3D;&gt; {
    try { Function(&quot;x\n &#x3D;&gt; 2&quot;)(); } catch(e) { return true; }
  })();
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - correct precedence
                    <pre><code>(function (){
  return (() &#x3D;&gt; {
    try { Function(&quot;0 || () &#x3D;&gt; 2&quot;)(); } catch(e) { return true; }
  })();
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - no &quot;prototype&quot; property
                    <pre><code>(function (){
  var a &#x3D; () &#x3D;&gt; 5;
  return !a.hasOwnProperty(&quot;prototype&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - lexical &quot;super&quot; binding in constructors
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var received;

  class B {
    constructor (arg) {
      received &#x3D; arg;
    }
  }
  class C extends B {
    constructor () {
      var callSuper &#x3D; () &#x3D;&gt; super(&#x27;foo&#x27;);
      callSuper();
    }
  }
  return new C instanceof C &amp;&amp; received &#x3D;&#x3D;&#x3D; &#x27;foo&#x27;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - lexical &quot;super&quot; binding in methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {
    qux() {
      return &quot;quux&quot;;
    }
  }
  class C extends B {
    baz() {
      return x &#x3D;&gt; super.qux();
    }
  }
  var arrow &#x3D; new C().baz();
  return arrow() &#x3D;&#x3D;&#x3D; &quot;quux&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - lexical &quot;new.target&quot; binding
                    <pre><code>(function (){
  function C() {
    return x &#x3D;&gt; new.target;
  }
  return new C()() &#x3D;&#x3D;&#x3D; C &amp;&amp; C()() &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - class

              <ul>
                <li>
                  SUCCESS - class statement
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {}
  return typeof C &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - is block-scoped
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {}
  var c1 &#x3D; C;
  {
    class C {}
    var c2 &#x3D; C;
  }
  return C &#x3D;&#x3D;&#x3D; c1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class expression
                    <pre><code>(function (){
  &quot;use strict&quot;;
  return typeof class C {} &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - anonymous class
                    <pre><code>(function (){
  &quot;use strict&quot;;
  return typeof class {} &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    constructor() { this.x &#x3D; 1; }
  }
  return C.prototype.constructor &#x3D;&#x3D;&#x3D; C
    &amp;&amp; new C().x &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - prototype methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    method() { return 2; }
  }
  return typeof C.prototype.method &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; new C().method() &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - string-keyed methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    &quot;foo bar&quot;() { return 2; }
  }
  return typeof C.prototype[&quot;foo bar&quot;] &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; new C()[&quot;foo bar&quot;]() &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed prototype methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var foo &#x3D; &quot;method&quot;;
  class C {
    [foo]() { return 2; }
  }
  return typeof C.prototype.method &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; new C().method() &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - optional semicolons
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    ;
    method() { return 2; };
    method2() { return 2; }
    method3() { return 2; };
  }
  return typeof C.prototype.method &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; typeof C.prototype.method2 &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; typeof C.prototype.method3 &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - static methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    static method() { return 3; }
  }
  return typeof C.method &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; C.method() &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed static methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var foo &#x3D; &quot;method&quot;;
  class C {
    static [foo]() { return 3; }
  }
  return typeof C.method &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; C.method() &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - accessor properties
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var baz &#x3D; false;
  class C {
    get foo() { return &quot;foo&quot;; }
    set bar(x) { baz &#x3D; x; }
  }
  new C().bar &#x3D; true;
  return new C().foo &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; baz;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed accessor properties
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var garply &#x3D; &quot;foo&quot;, grault &#x3D; &quot;bar&quot;, baz &#x3D; false;
  class C {
    get [garply]() { return &quot;foo&quot;; }
    set [grault](x) { baz &#x3D; x; }
  }
  new C().bar &#x3D; true;
  return new C().foo &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; baz;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - static accessor properties
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var baz &#x3D; false;
  class C {
    static get foo() { return &quot;foo&quot;; }
    static set bar(x) { baz &#x3D; x; }
  }
  C.bar &#x3D; true;
  return C.foo &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; baz;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed static accessor properties
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var garply &#x3D; &quot;foo&quot;, grault &#x3D; &quot;bar&quot;, baz &#x3D; false;
  class C {
    static get [garply]() { return &quot;foo&quot;; }
    static set [grault](x) { baz &#x3D; x; }
  }
  C.bar &#x3D; true;
  return C.foo &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; baz;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class name is lexically scoped
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    method() { return typeof C &#x3D;&#x3D;&#x3D; &quot;function&quot;; }
  }
  var M &#x3D; C.prototype.method;
  C &#x3D; undefined;
  return C &#x3D;&#x3D;&#x3D; undefined &amp;&amp; M();
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed names, temporal dead zone
                    <pre><code>(function (){
  &quot;use strict&quot;;
  try {
    var B &#x3D; class C {
      [C](){}
    }
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - methods aren&#x27;t enumerable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    foo() {}
    static bar() {}
  }
  return !C.prototype.propertyIsEnumerable(&quot;foo&quot;) &amp;&amp; !C.propertyIsEnumerable(&quot;bar&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - implicit strict mode
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    static method() { return this &#x3D;&#x3D;&#x3D; undefined; }
  }
  return (0,C.method)();
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {}
  try {
    C();
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - extends
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {}
  class C extends B {}
  return new C() instanceof B
    &amp;&amp; B.isPrototypeOf(C);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - extends expressions
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var B;
  class C extends (B &#x3D; class {}) {}
  return new C() instanceof B
    &amp;&amp; B.isPrototypeOf(C);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - extends null
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends null {
    constructor() { return Object.create(null); }
  }
  return Function.prototype.isPrototypeOf(C)
    &amp;&amp; Object.getPrototypeOf(C.prototype) &#x3D;&#x3D;&#x3D; null;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - new.target
                    <pre><code>(function (){
  var passed &#x3D; false;
  new function f() {
    passed &#x3D; new.target &#x3D;&#x3D;&#x3D; f;
  }();

  class A {
    constructor() {
      passed &amp;&#x3D; new.target &#x3D;&#x3D;&#x3D; B;
    }
  }
  class B extends A {}
  new B();
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - super

              <ul>
                <li>
                  SUCCESS - statement in constructors
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var passed &#x3D; false;
  class B {
    constructor(a) { passed &#x3D; (a &#x3D;&#x3D;&#x3D; &quot;barbaz&quot;); }
  }
  class C extends B {
    constructor(a) { super(&quot;bar&quot; + a); }
  }
  new C(&quot;baz&quot;);
  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - expression in constructors
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {
    constructor(a) { return [&quot;foo&quot; + a]; }
  }
  class C extends B {
    constructor(a) { return super(&quot;bar&quot; + a); }
  }
  return new C(&quot;baz&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - in methods, property access
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {}
  B.prototype.qux &#x3D; &quot;foo&quot;;
  B.prototype.corge &#x3D; &quot;baz&quot;;
  class C extends B {
    quux(a) { return super.qux + a + super[&quot;corge&quot;]; }
  }
  C.prototype.qux &#x3D; &quot;garply&quot;;
  return new C().quux(&quot;bar&quot;) &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - in methods, method calls
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {
    qux(a) { return &quot;foo&quot; + a; }
  }
  class C extends B {
    qux(a) { return super.qux(&quot;bar&quot; + a); }
  }
  return new C().qux(&quot;baz&quot;) &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - method calls use correct &quot;this&quot; binding
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {
    qux(a) { return this.foo + a; }
  }
  class C extends B {
    qux(a) { return super.qux(&quot;bar&quot; + a); }
  }
  var obj &#x3D; new C();
  obj.foo &#x3D; &quot;foo&quot;;
  return obj.qux(&quot;baz&quot;) &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - constructor calls use correct &quot;new.target&quot; binding
                    <pre><code>(function (){
  var passed;
  class B {
    constructor() { passed &#x3D; (new.target &#x3D;&#x3D;&#x3D; C); }
  }
  class C extends B {
    constructor() { super(); }
  }
  new C();
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - is statically bound
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class B {
    qux() { return &quot;bar&quot;; }
  }
  class C extends B {
    qux() { return super.qux() + this.corge; }
  }
  var obj &#x3D; {
    qux: C.prototype.qux,
    corge: &quot;ley&quot;
  };
  return obj.qux() &#x3D;&#x3D;&#x3D; &quot;barley&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - super() invokes the correct constructor
                    <pre><code>(function (){
  &quot;use strict&quot;;
  // checks that super() is *not* a synonym of super.constructor()
  var passed;
  class B {
      constructor() {
          passed &#x3D; true;
      }
  };
  B.prototype.constructor &#x3D; function () {
      passed &#x3D; false;
  };
  class C extends B { };
  new C;
  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - generators

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  function * generator(){
    yield 5; yield 6;
  };
  var iterator &#x3D; generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - generator function expressions
                    <pre><code>(function (){
  var generator &#x3D; function * (){
    yield 5; yield 6;
  };
  var iterator &#x3D; generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - correct &quot;this&quot; binding
                    <pre><code>(function (){
  function * generator(){
    yield this.x; yield this.y;
  };
  var iterator &#x3D; { g: generator, x: 5, y: 6 }.g();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - can&#x27;t use &quot;this&quot; with new
                    <pre><code>(function (){
  function * generator(){
    yield this.x; yield this.y;
  };
  try {
    (new generator()).next();
  }
  catch (e) {
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - sending
                    <pre><code>(function (){
  var sent;
  function * generator(){
    sent &#x3D; [yield 5, yield 6];
  };
  var iterator &#x3D; generator();
  iterator.next();
  iterator.next(&quot;foo&quot;);
  iterator.next(&quot;bar&quot;);
  return sent[0] &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; sent[1] &#x3D;&#x3D;&#x3D; &quot;bar&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %GeneratorPrototype%
                    <pre><code>(function (){
  function * generatorFn(){}
  var ownProto &#x3D; Object.getPrototypeOf(generatorFn());
  var passed &#x3D; ownProto &#x3D;&#x3D;&#x3D; generatorFn.prototype;

  var sharedProto &#x3D; Object.getPrototypeOf(ownProto);
  passed &amp;&#x3D; sharedProto !&#x3D;&#x3D; Object.prototype &amp;&amp;
    sharedProto &#x3D;&#x3D;&#x3D; Object.getPrototypeOf(function*(){}.prototype) &amp;&amp;
    sharedProto.hasOwnProperty(&#x27;next&#x27;);

  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %GeneratorPrototype% prototype chain
                    <pre><code>(function (){
  function * generatorFn(){}
  var g &#x3D; generatorFn();
  var ownProto &#x3D; Object.getPrototypeOf(g);
  var passed &#x3D; ownProto &#x3D;&#x3D;&#x3D; generatorFn.prototype;

  var sharedProto &#x3D; Object.getPrototypeOf(ownProto);
  var iterProto &#x3D; Object.getPrototypeOf(sharedProto);

  passed &amp;&#x3D; iterProto.hasOwnProperty(Symbol.iterator) &amp;&amp;
    !sharedProto     .hasOwnProperty(Symbol.iterator) &amp;&amp;
    !ownProto        .hasOwnProperty(Symbol.iterator) &amp;&amp;
    g[Symbol.iterator]() &#x3D;&#x3D;&#x3D; g;

  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %GeneratorPrototype%.constructor
                    <pre><code>(function (){
  function * g (){}
  var iterator &#x3D; new g.constructor(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;yield a; yield b; yield c;&quot;)(5,6,7);
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 7 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;

  passed &amp;&#x3D; g.constructor &#x3D;&#x3D;&#x3D; (function*(){}).constructor;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %GeneratorPrototype%.throw
                    <pre><code>(function (){
  var passed &#x3D; false;
  function * generator(){
    try {
      yield 5; yield 6;
    } catch(e) {
      passed &#x3D; (e &#x3D;&#x3D;&#x3D; &quot;foo&quot;);
    }
  };
  var iterator &#x3D; generator();
  iterator.next();
  iterator.throw(&quot;foo&quot;);
  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - %GeneratorPrototype%.return
                    <pre><code>(function (){
  function * generator(){
    yield 5; yield 6;
  };
  var iterator &#x3D; generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.return(&quot;quxquux&quot;);
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; &quot;quxquux&quot; &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: TypeError: iterator.return is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield operator precedence
                    <pre><code>(function (){
  var passed;
  function * generator(){
    passed &#x3D; yield 0 ? true : false;
  };
  var iterator &#x3D; generator();
  iterator.next();
  iterator.next(true);
  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield *, arrays
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * [5, 6];
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield *, sparse arrays
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * [,,];
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield *, strings
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * &quot;56&quot;;
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; &quot;5&quot; &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; &quot;6&quot; &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield *, astral plane strings
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * &quot;𠮷𠮶&quot;;
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; &quot;𠮷&quot; &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; &quot;𠮶&quot; &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield *, generator instances
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * (function*(){ yield 5; yield 6; yield 7; }());
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 7 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - yield *, generic iterables
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * global.__createIterableObject([5, 6, 7]);
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 7 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject(...)[(intermediate value)] is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - yield *, instances of iterables
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * Object.create(__createIterableObject([5, 6, 7]));
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 7 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: __createIterableObject is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - yield * on non-iterables is a runtime error
                    <pre><code>(function (){
  var iterator &#x3D; (function * generator() {
    yield * [5];
  }());
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  iterator &#x3D; (function * generator() {
    yield * 5;
  }());
  try {
    iterator.next();
  } catch (e) {
    return passed;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - yield *, iterator closing
                    <pre><code>(function (){
  var closed &#x3D; &#x27;&#x27;;
  var iter &#x3D; __createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){
      closed +&#x3D; &#x27;a&#x27;;
      return {done: true};
    }
  });
  var gen &#x3D; (function* generator(){
    try {
      yield *iter;
    } finally {
      closed +&#x3D; &#x27;b&#x27;;
    }
  })();
  gen.next();
  gen[&#x27;return&#x27;]();
  return closed &#x3D;&#x3D;&#x3D; &#x27;ab&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: __createIterableObject is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - yield *, iterator closing via throw()
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;throw&#x27;: undefined,
    &#x27;return&#x27;: function() {
      closed &#x3D; true;
      return {done: true};
    }
  });
  var gen &#x3D; (function*(){
    try {
      yield *iter;
    } catch(e){}
  })();
  gen.next();
  gen[&#x27;throw&#x27;]();
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand generator methods
                    <pre><code>(function (){
  var o &#x3D; {
    * generator() {
      yield 5; yield 6;
    },
  };
  var iterator &#x3D; o.generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - string-keyed shorthand generator methods
                    <pre><code>(function (){
  var o &#x3D; {
    * &quot;foo bar&quot;() {
      yield 5; yield 6;
    },
  };
  var iterator &#x3D; o[&quot;foo bar&quot;]();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed shorthand generators
                    <pre><code>(function (){
  var garply &#x3D; &quot;generator&quot;;
  var o &#x3D; {
    * [garply] () {
      yield 5; yield 6;
    },
  };
  var iterator &#x3D; o.generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand generator methods, classes
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    * generator() {
      yield 5; yield 6;
    }
  };
  var iterator &#x3D; new C().generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - computed shorthand generators, classes
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var garply &#x3D; &quot;generator&quot;;
  class C {
    * [garply] () {
      yield 5; yield 6;
    }
  }
  var iterator &#x3D; new C().generator();
  var item &#x3D; iterator.next();
  var passed &#x3D; item.value &#x3D;&#x3D;&#x3D; 5 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; 6 &amp;&amp; item.done &#x3D;&#x3D;&#x3D; false;
  item &#x3D; iterator.next();
  passed    &amp;&#x3D; item.value &#x3D;&#x3D;&#x3D; undefined &amp;&amp; item.done &#x3D;&#x3D;&#x3D; true;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand generators can&#x27;t be constructors
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C {
    * generator() {
      yield 5; yield 6;
    }
  };
  try {
    Function(&quot;class D { * constructor() { return {}; } }&quot;);
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - typed arrays

              <ul>
                <li>
                  SUCCESS - Int8Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Int8Array(buffer);         view[0] &#x3D; 0x80;
  return view[0] &#x3D;&#x3D;&#x3D; -0x80;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Uint8Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Uint8Array(buffer);        view[0] &#x3D; 0x100;
  return view[0] &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Uint8ClampedArray
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Uint8ClampedArray(buffer); view[0] &#x3D; 0x100;
  return view[0] &#x3D;&#x3D;&#x3D; 0xFF;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Int16Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Int16Array(buffer);        view[0] &#x3D; 0x8000;
  return view[0] &#x3D;&#x3D;&#x3D; -0x8000;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Uint16Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Uint16Array(buffer);       view[0] &#x3D; 0x10000;
  return view[0] &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Int32Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Int32Array(buffer);        view[0] &#x3D; 0x80000000;
  return view[0] &#x3D;&#x3D;&#x3D; -0x80000000;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Uint32Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Uint32Array(buffer);       view[0] &#x3D; 0x100000000;
  return view[0] &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Float32Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Float32Array(buffer);       view[0] &#x3D; 0.1;
  return view[0] &#x3D;&#x3D;&#x3D; 0.10000000149011612;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Float64Array
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new Float64Array(buffer);       view[0] &#x3D; 0.1;
  return view[0] &#x3D;&#x3D;&#x3D; 0.1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Int8)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setInt8 (0, 0x80);
  return view.getInt8(0) &#x3D;&#x3D;&#x3D; -0x80;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Uint8)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setUint8(0, 0x100);
  return view.getUint8(0) &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Int16)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setInt16(0, 0x8000);
  return view.getInt16(0) &#x3D;&#x3D;&#x3D; -0x8000;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Uint16)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setUint16(0, 0x10000);
  return view.getUint16(0) &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Int32)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setInt32(0, 0x80000000);
  return view.getInt32(0) &#x3D;&#x3D;&#x3D; -0x80000000;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Uint32)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setUint32(0, 0x100000000);
  return view.getUint32(0) &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Float32)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setFloat32(0, 0.1);
  return view.getFloat32(0) &#x3D;&#x3D;&#x3D; 0.10000000149011612;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - DataView (Float64)
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var view &#x3D; new DataView(buffer);
  view.setFloat64(0, 0.1);
  return view.getFloat64(0) &#x3D;&#x3D;&#x3D; 0.1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - ArrayBuffer[Symbol.species]
                    <pre><code>(function (){
  return typeof ArrayBuffer[Symbol.species] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructors require new
                    <pre><code>(function (){
  var buffer &#x3D; new ArrayBuffer(64);
  var constructors &#x3D; [
    &#x27;ArrayBuffer&#x27;,
    &#x27;DataView&#x27;,
    &#x27;Int8Array&#x27;,
    &#x27;Uint8Array&#x27;,
    &#x27;Uint8ClampedArray&#x27;,
    &#x27;Int16Array&#x27;,
    &#x27;Uint16Array&#x27;,
    &#x27;Int32Array&#x27;,
    &#x27;Uint32Array&#x27;,
    &#x27;Float32Array&#x27;,
    &#x27;Float64Array&#x27;
  ];
  return constructors.every(function (constructor) {
    try {
      if (constructor in global) {
        global[constructor](constructor &#x3D;&#x3D;&#x3D; &quot;ArrayBuffer&quot; ? 64 : buffer);
      }
      return false;
    } catch(e) {
      return true;
    }
  });
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - constructors accept generic iterables
                    <pre><code>(function (){
  var constructors &#x3D; [
    &#x27;Int8Array&#x27;,
    &#x27;Uint8Array&#x27;,
    &#x27;Uint8ClampedArray&#x27;,
    &#x27;Int16Array&#x27;,
    &#x27;Uint16Array&#x27;,
    &#x27;Int32Array&#x27;,
    &#x27;Uint32Array&#x27;,
    &#x27;Float32Array&#x27;,
    &#x27;Float64Array&#x27;
  ];
  for(var i &#x3D; 0; i &lt; constructors.length; i++){
    var arr &#x3D; new global[constructors[i]](__createIterableObject([1, 2, 3]));
    if(arr.length !&#x3D;&#x3D; 3 || arr[0] !&#x3D;&#x3D; 1 || arr[1] !&#x3D;&#x3D; 2 || arr[2] !&#x3D;&#x3D; 3)return false;
  }
  return true;
})()</code></pre>
                    <span>Result: ReferenceError: __createIterableObject is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - correct prototype chains
                    <pre><code>(function (){
  var constructors &#x3D; [
    &#x27;Int8Array&#x27;,
    &#x27;Uint8Array&#x27;,
    &#x27;Uint8ClampedArray&#x27;,
    &#x27;Int16Array&#x27;,
    &#x27;Uint16Array&#x27;,
    &#x27;Int32Array&#x27;,
    &#x27;Uint32Array&#x27;,
    &#x27;Float32Array&#x27;,
    &#x27;Float64Array&#x27;
  ];
  var constructor &#x3D; Object.getPrototypeOf(Int8Array);
  var prototype &#x3D; Object.getPrototypeOf(Int8Array.prototype);
  if(constructor &#x3D;&#x3D;&#x3D; Function.prototype || prototype &#x3D;&#x3D;&#x3D; Object.prototype)return false;
  for(var i &#x3D; 0; i &lt; constructors.length; i+&#x3D;1) {
    if (!(constructors[i] in global
        &amp;&amp; Object.getPrototypeOf(global[constructors[i]]) &#x3D;&#x3D;&#x3D; constructor
        &amp;&amp; Object.getPrototypeOf(global[constructors[i]].prototype) &#x3D;&#x3D;&#x3D; prototype
        &amp;&amp; Object.getOwnPropertyNames(global[constructors[i]].prototype).sort() + &#x27;&#x27;
          &#x3D;&#x3D;&#x3D; &quot;BYTES_PER_ELEMENT,constructor&quot;)) {
      return false;
    }
  }
  return true;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.from
                    <pre><code>(function (){
return typeof Int8Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.from &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.of
                    <pre><code>(function (){
return typeof Int8Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.of &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.subarray
                    <pre><code>(function (){
return typeof Int8Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.subarray &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.join
                    <pre><code>(function (){
return typeof Int8Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.join &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.indexOf
                    <pre><code>(function (){
return typeof Int8Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.indexOf &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.lastIndexOf
                    <pre><code>(function (){
return typeof Int8Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.lastIndexOf &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.slice
                    <pre><code>(function (){
return typeof Int8Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.slice &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.every
                    <pre><code>(function (){
return typeof Int8Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.every &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.filter
                    <pre><code>(function (){
return typeof Int8Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.filter &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.forEach
                    <pre><code>(function (){
return typeof Int8Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.map
                    <pre><code>(function (){
return typeof Int8Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.map &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.reduce
                    <pre><code>(function (){
return typeof Int8Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.reduce &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.reduceRight
                    <pre><code>(function (){
return typeof Int8Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.reduceRight &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.reverse
                    <pre><code>(function (){
return typeof Int8Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.reverse &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.some
                    <pre><code>(function (){
return typeof Int8Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.some &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.sort
                    <pre><code>(function (){
return typeof Int8Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.sort &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.copyWithin
                    <pre><code>(function (){
return typeof Int8Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.find
                    <pre><code>(function (){
return typeof Int8Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.find &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.findIndex
                    <pre><code>(function (){
return typeof Int8Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.fill
                    <pre><code>(function (){
return typeof Int8Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.fill &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.keys
                    <pre><code>(function (){
return typeof Int8Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.values
                    <pre><code>(function (){
return typeof Int8Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype.entries
                    <pre><code>(function (){
return typeof Int8Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - %TypedArray%.prototype[Symbol.iterator]
                    <pre><code>(function (){
return typeof Int8Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - %TypedArray%[Symbol.species]
                    <pre><code>(function (){
return typeof Int8Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint8ClampedArray[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int16Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint16Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Int32Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Uint32Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float32Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp;
  typeof Float64Array[Symbol.species] &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Map

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var key &#x3D; {};
  var map &#x3D; new Map();

  map.set(key, 123);

  return map.has(key) &amp;&amp; map.get(key) &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor arguments
                    <pre><code>(function (){
  var key1 &#x3D; {};
  var key2 &#x3D; {};
  var map &#x3D; new Map([[key1, 123], [key2, 456]]);

  return map.has(key1) &amp;&amp; map.get(key1) &#x3D;&#x3D;&#x3D; 123 &amp;&amp;
         map.has(key2) &amp;&amp; map.get(key2) &#x3D;&#x3D;&#x3D; 456;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  new Map();
  try {
    Map();
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor accepts null
                    <pre><code>(function (){
  new Map(null);
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor invokes set
                    <pre><code>(function (){
  var passed &#x3D; false;
  var _set &#x3D; Map.prototype.set;

  Map.prototype.set &#x3D; function(k, v) {
    passed &#x3D; true;
  };

  new Map([ [1, 2] ]);
  Map.prototype.set &#x3D; _set;

  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  try {
    new Map(iter);
  } catch(e){}
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.set returns this
                    <pre><code>(function (){
  var map &#x3D; new Map();
  return map.set(0, 0) &#x3D;&#x3D;&#x3D; map;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - -0 key converts to +0
                    <pre><code>(function (){
  var map &#x3D; new Map();
  map.set(-0, &quot;foo&quot;);
  var k;
  map.forEach(function (value, key) {
    k &#x3D; 1 / key;
  });
  return k &#x3D;&#x3D;&#x3D; Infinity &amp;&amp; map.get(+0) &#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.size
                    <pre><code>(function (){
  var key &#x3D; {};
  var map &#x3D; new Map();

  map.set(key, 123);

  return map.size &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.delete
                    <pre><code>(function (){
  return typeof Map.prototype.delete &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.clear
                    <pre><code>(function (){
  return typeof Map.prototype.clear &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.forEach
                    <pre><code>(function (){
  return typeof Map.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.keys
                    <pre><code>(function (){
  return typeof Map.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.values
                    <pre><code>(function (){
  return typeof Map.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype.entries
                    <pre><code>(function (){
  return typeof Map.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype[Symbol.iterator]
                    <pre><code>(function (){
  return typeof Map.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map.prototype isn&#x27;t an instance
                    <pre><code>(function (){
  new Map();
  var obj &#x3D; {};
  try {
    Map.prototype.has(obj);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map iterator prototype chain
                    <pre><code>(function (){
  // Iterator instance
  var iterator &#x3D; new Map()[Symbol.iterator]();
  // %MapIteratorPrototype%
  var proto1 &#x3D; Object.getPrototypeOf(iterator);
  // %IteratorPrototype%
  var proto2 &#x3D; Object.getPrototypeOf(proto1);

  return proto2.hasOwnProperty(Symbol.iterator) &amp;&amp;
    !proto1    .hasOwnProperty(Symbol.iterator) &amp;&amp;
    !iterator  .hasOwnProperty(Symbol.iterator) &amp;&amp;
    iterator[Symbol.iterator]() &#x3D;&#x3D;&#x3D; iterator;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Map[Symbol.species]
                    <pre><code>(function (){
  var prop &#x3D; Object.getOwnPropertyDescriptor(Map, Symbol.species);
  return &#x27;get&#x27; in prop &amp;&amp; Map[Symbol.species] &#x3D;&#x3D;&#x3D; Map;
})()</code></pre>
                    <span>Result: TypeError: Cannot use &#x27;in&#x27; operator to search for &#x27;get&#x27; in undefined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Set

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var obj &#x3D; {};
  var set &#x3D; new Set();

  set.add(123);
  set.add(123);

  return set.has(123);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor arguments
                    <pre><code>(function (){
  var obj1 &#x3D; {};
  var obj2 &#x3D; {};
  var set &#x3D; new Set([obj1, obj2]);

  return set.has(obj1) &amp;&amp; set.has(obj2);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  new Set();
  try {
    Set();
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor accepts null
                    <pre><code>(function (){
  new Set(null);
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor invokes add
                    <pre><code>(function (){
  var passed &#x3D; false;
  var _add &#x3D; Set.prototype.add;

  Set.prototype.add &#x3D; function(v) {
    passed &#x3D; true;
  };

  new Set([1]);
  Set.prototype.add &#x3D; _add;

  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  var add &#x3D; Set.prototype.add;
  Set.prototype.add &#x3D; function(){ throw 0 };
  try {
    new Set(iter);
  } catch(e){}
  Set.prototype.add &#x3D; add;
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.add returns this
                    <pre><code>(function (){
  var set &#x3D; new Set();
  return set.add(0) &#x3D;&#x3D;&#x3D; set;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - -0 key converts to +0
                    <pre><code>(function (){
  var set &#x3D; new Set();
  set.add(-0);
  var k;
  set.forEach(function (value) {
    k &#x3D; 1 / value;
  });
  return k &#x3D;&#x3D;&#x3D; Infinity &amp;&amp; set.has(+0);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.size
                    <pre><code>(function (){
  var obj &#x3D; {};
  var set &#x3D; new Set();

  set.add(123);
  set.add(123);
  set.add(456);

  return set.size &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.delete
                    <pre><code>(function (){
  return typeof Set.prototype.delete &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.clear
                    <pre><code>(function (){
  return typeof Set.prototype.clear &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.forEach
                    <pre><code>(function (){
  return typeof Set.prototype.forEach &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.keys
                    <pre><code>(function (){
  return typeof Set.prototype.keys &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.values
                    <pre><code>(function (){
  return typeof Set.prototype.values &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype.entries
                    <pre><code>(function (){
  return typeof Set.prototype.entries &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype[Symbol.iterator]
                    <pre><code>(function (){
  return typeof Set.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set.prototype isn&#x27;t an instance
                    <pre><code>(function (){
  new Set();
  var obj &#x3D; {};
  try {
    Set.prototype.has(obj);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set iterator prototype chain
                    <pre><code>(function (){
  // Iterator instance
  var iterator &#x3D; new Set()[Symbol.iterator]();
  // %SetIteratorPrototype%
  var proto1 &#x3D; Object.getPrototypeOf(iterator);
  // %IteratorPrototype%
  var proto2 &#x3D; Object.getPrototypeOf(proto1);

  return proto2.hasOwnProperty(Symbol.iterator) &amp;&amp;
    !proto1    .hasOwnProperty(Symbol.iterator) &amp;&amp;
    !iterator  .hasOwnProperty(Symbol.iterator) &amp;&amp;
    iterator[Symbol.iterator]() &#x3D;&#x3D;&#x3D; iterator;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Set[Symbol.species]
                    <pre><code>(function (){
  var prop &#x3D; Object.getOwnPropertyDescriptor(Set, Symbol.species);
  return &#x27;get&#x27; in prop &amp;&amp; Set[Symbol.species] &#x3D;&#x3D;&#x3D; Set;
})()</code></pre>
                    <span>Result: TypeError: Cannot use &#x27;in&#x27; operator to search for &#x27;get&#x27; in undefined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - WeakMap

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var key &#x3D; {};
  var weakmap &#x3D; new WeakMap();

  weakmap.set(key, 123);

  return weakmap.has(key) &amp;&amp; weakmap.get(key) &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor arguments
                    <pre><code>(function (){
  var key1 &#x3D; {};
  var key2 &#x3D; {};
  var weakmap &#x3D; new WeakMap([[key1, 123], [key2, 456]]);

  return weakmap.has(key1) &amp;&amp; weakmap.get(key1) &#x3D;&#x3D;&#x3D; 123 &amp;&amp;
         weakmap.has(key2) &amp;&amp; weakmap.get(key2) &#x3D;&#x3D;&#x3D; 456;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  new WeakMap();
  try {
    WeakMap();
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor accepts null
                    <pre><code>(function (){
  new WeakMap(null);
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor invokes set
                    <pre><code>(function (){
  var passed &#x3D; false;
  var _set &#x3D; WeakMap.prototype.set;

  WeakMap.prototype.set &#x3D; function(k, v) {
    passed &#x3D; true;
  };

  new WeakMap([ [{ }, 42] ]);
  WeakMap.prototype.set &#x3D; _set;

  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - frozen objects as keys
                    <pre><code>(function (){
  var f &#x3D; Object.freeze({});
  var m &#x3D; new WeakMap;
  m.set(f, 42);
  return m.get(f) &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  try {
    new WeakMap(iter);
  } catch(e){}
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakMap.prototype.set returns this
                    <pre><code>(function (){
  var weakmap &#x3D; new WeakMap();
  var key &#x3D; {};
  return weakmap.set(key, 0) &#x3D;&#x3D;&#x3D; weakmap;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakMap.prototype.delete
                    <pre><code>(function (){
  return typeof WeakMap.prototype.delete &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - no WeakMap.prototype.clear method
                    <pre><code>(function (){
  if (!(&quot;clear&quot; in WeakMap.prototype)) {
    return true;
  }
  var m &#x3D; new WeakMap();
  var key &#x3D; {};
  m.set(key, 2);
  m.clear();
  return m.has(key);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - .has, .get and .delete methods accept primitives
                    <pre><code>(function (){
  var m &#x3D; new WeakMap;
  return m.has(1) &#x3D;&#x3D;&#x3D; false
    &amp;&amp; m.get(1) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; m.delete(1) &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakMap.prototype isn&#x27;t an instance
                    <pre><code>(function (){
  new WeakMap();
  var obj &#x3D; {};
  try {
    WeakMap.prototype.has(obj);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - WeakSet

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var obj1 &#x3D; {};
  var weakset &#x3D; new WeakSet();

  weakset.add(obj1);
  weakset.add(obj1);

  return weakset.has(obj1);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor arguments
                    <pre><code>(function (){
  var obj1 &#x3D; {}, obj2 &#x3D; {};
  var weakset &#x3D; new WeakSet([obj1, obj2]);

  return weakset.has(obj1) &amp;&amp; weakset.has(obj2);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  new WeakSet();
  try {
    WeakSet();
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor accepts null
                    <pre><code>(function (){
  new WeakSet(null);
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor invokes add
                    <pre><code>(function (){
  var passed &#x3D; false;
  var _add &#x3D; WeakSet.prototype.add;

  WeakSet.prototype.add &#x3D; function(v) {
    passed &#x3D; true;
  };

  new WeakSet([ { } ]);
  WeakSet.prototype.add &#x3D; _add;

  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  try {
    new WeakSet(iter);
  } catch(e){}
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakSet.prototype.add returns this
                    <pre><code>(function (){
  var weakset &#x3D; new WeakSet();
  var obj &#x3D; {};
  return weakset.add(obj) &#x3D;&#x3D;&#x3D; weakset;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakSet.prototype.delete
                    <pre><code>(function (){
  return typeof WeakSet.prototype.delete &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - no WeakSet.prototype.clear method
                    <pre><code>(function (){
  if (!(&quot;clear&quot; in WeakSet.prototype)) {
    return true;
  }
  var s &#x3D; new WeakSet();
  var key &#x3D; {};
  s.add(key);
  s.clear();
  return s.has(key);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - .has and .delete methods accept primitives
                    <pre><code>(function (){
  var s &#x3D; new WeakSet;
  return s.has(1) &#x3D;&#x3D;&#x3D; false
    &amp;&amp; s.delete(1) &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - WeakSet.prototype isn&#x27;t an instance
                    <pre><code>(function (){
  new WeakSet();
  var obj &#x3D; {};
  try {
    WeakSet.prototype.has(obj);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy

              <ul>
                <li>
                  FAIL - constructor requires new
                    <pre><code>(function (){
  new Proxy({}, {});
  try {
    Proxy({}, {});
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - no &quot;prototype&quot; property
                    <pre><code>(function (){
  new Proxy({}, {});
  return !Proxy.hasOwnProperty(&#x27;prototype&#x27;);
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;get&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; { };
  var proxy &#x3D; new Proxy(proxied, {
    get: function (t, k, r) {
      return t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; r &#x3D;&#x3D;&#x3D; proxy &amp;&amp; 5;
    }
  });
  return proxy.foo &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;get&quot; handler, instances of proxies
                    <pre><code>(function (){
  var proxied &#x3D; { };
  var proxy &#x3D; Object.create(new Proxy(proxied, {
    get: function (t, k, r) {
      return t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; r &#x3D;&#x3D;&#x3D; proxy &amp;&amp; 5;
    }
  }));
  return proxy.foo &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;get&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  var proxied &#x3D; { };
  var proxy &#x3D; new Proxy(proxied, {
    get: function () {
      passed &#x3D; true;
      return 4;
    }
  });
  // The value reported for a property must be the same as the value of the corresponding
  // target object property if the target object property is a non-writable,
  // non-configurable own data property.
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 5, enumerable: true });
  try {
    proxy.foo;
    return false;
  }
  catch(e) {}
  // The value reported for a property must be undefined if the corresponding target
  // object property is a non-configurable own accessor property that has undefined
  // as its [[Get]] attribute.
  Object.defineProperty(proxied, &quot;bar&quot;,
    { set: function(){}, enumerable: true });
  try {
    proxy.bar;
    return false;
  }
  catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;set&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; { };
  var passed &#x3D; false;
  var proxy &#x3D; new Proxy(proxied, {
    set: function (t, k, v, r) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k + v &#x3D;&#x3D;&#x3D; &quot;foobar&quot; &amp;&amp; r &#x3D;&#x3D;&#x3D; proxy;
    }
  });
  proxy.foo &#x3D; &quot;bar&quot;;
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;set&quot; handler, instances of proxies
                    <pre><code>(function (){
  var proxied &#x3D; { };
  var passed &#x3D; false;
  var proxy &#x3D; Object.create(new Proxy(proxied, {
    set: function (t, k, v, r) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k + v &#x3D;&#x3D;&#x3D; &quot;foobar&quot; &amp;&amp; r &#x3D;&#x3D;&#x3D; proxy;
    }
  }));
  proxy.foo &#x3D; &quot;bar&quot;;
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;set&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // Cannot change the value of a property to be different from the value of
  // the corresponding target object if the corresponding target object
  // property is a non-writable, non-configurable own data property.
  var proxied &#x3D; {};
  var proxy &#x3D; new Proxy(proxied, {
    set: function () {
      passed &#x3D; true;
      return true;
    }
  });
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 2, enumerable: true });
  proxy.foo &#x3D; 2;
  try {
    proxy.foo &#x3D; 4;
    return false;
  } catch(e) {}
  // Cannot set the value of a property if the corresponding target
  // object property is a non-configurable own accessor property
  // that has undefined as its [[Set]] attribute.
  Object.defineProperty(proxied, &quot;bar&quot;,
    { get: function(){}, enumerable: true });
  try {
    proxy.bar &#x3D; 2;
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;has&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  &quot;foo&quot; in new Proxy(proxied, {
    has: function (t, k) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
    }
  });
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;has&quot; handler, instances of proxies
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  &quot;foo&quot; in Object.create(new Proxy(proxied, {
    has: function (t, k) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
    }
  }));
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;has&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // A property cannot be reported as non-existent, if it exists as a
  // non-configurable own property of the target object.
  var proxied &#x3D; {};
  var proxy &#x3D; new Proxy(proxied, {
    has: function () {
      passed &#x3D; true;
      return false;
    }
  });
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 2, writable: true, enumerable: true });
  try {
    &#x27;foo&#x27; in proxy;
    return false;
  } catch(e) {}
  // A property cannot be reported as non-existent, if it exists as an
  // own property of the target object and the target object is not extensible.
  proxied.bar &#x3D; 2;
  Object.preventExtensions(proxied);
  try {
    &#x27;bar&#x27; in proxy;
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;deleteProperty&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  delete new Proxy(proxied, {
    deleteProperty: function (t, k) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
    }
  }).foo;
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;deleteProperty&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // A property cannot be reported as deleted, if it exists as a non-configurable
  // own property of the target object.
  var proxied &#x3D; {};
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 2, writable: true, enumerable: true });
  try {
    delete new Proxy(proxied, {
      deleteProperty: function () {
        passed &#x3D; true;
        return true;
      }
    }).foo;
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;getOwnPropertyDescriptor&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var fakeDesc &#x3D; { value: &quot;foo&quot;, configurable: true };
  var returnedDesc &#x3D; Object.getOwnPropertyDescriptor(
    new Proxy(proxied, {
      getOwnPropertyDescriptor: function (t, k) {
        return t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; fakeDesc;
      }
    }),
    &quot;foo&quot;
  );
  return (returnedDesc.value     &#x3D;&#x3D;&#x3D; fakeDesc.value
    &amp;&amp; returnedDesc.configurable &#x3D;&#x3D;&#x3D; fakeDesc.configurable
    &amp;&amp; returnedDesc.writable     &#x3D;&#x3D;&#x3D; false
    &amp;&amp; returnedDesc.enumerable   &#x3D;&#x3D;&#x3D; false);
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;getOwnPropertyDescriptor&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // A property cannot be reported as non-existent, if it exists as a non-configurable
  // own property of the target object.
  var proxied &#x3D; {};
  var proxy &#x3D; new Proxy(proxied, {
    getOwnPropertyDescriptor: function () {
      passed &#x3D; true;
      return undefined;
    }
  });
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 2, writable: true, enumerable: true });
  try {
    Object.getOwnPropertyDescriptor(proxy, &quot;foo&quot;);
    return false;
  } catch(e) {}
  // A property cannot be reported as non-existent, if it exists as an own property
  // of the target object and the target object is not extensible.
  proxied.bar &#x3D; 3;
  Object.preventExtensions(proxied);
  try {
    Object.getOwnPropertyDescriptor(proxy, &quot;bar&quot;);
    return false;
  } catch(e) {}
  // A property cannot be reported as existent, if it does not exists as an own property
  // of the target object and the target object is not extensible.
  try {
    Object.getOwnPropertyDescriptor(new Proxy(proxied, {
      getOwnPropertyDescriptor: function() {
        return { value: 2, configurable: true, writable: true, enumerable: true };
      }}), &quot;baz&quot;);
    return false;
  } catch(e) {}
  // A property cannot be reported as non-configurable, if it does not exists as an own
  // property of the target object or if it exists as a configurable own property of
  // the target object.
  try {
    Object.getOwnPropertyDescriptor(new Proxy({}, {
      getOwnPropertyDescriptor: function() {
        return { value: 2, configurable: false, writable: true, enumerable: true };
      }}), &quot;baz&quot;);
    return false;
  } catch(e) {}
  try {
    Object.getOwnPropertyDescriptor(new Proxy({baz:1}, {
      getOwnPropertyDescriptor: function() {
        return { value: 1, configurable: false, writable: true, enumerable: true };
      }}), &quot;baz&quot;);
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;defineProperty&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  Object.defineProperty(
    new Proxy(proxied, {
      defineProperty: function (t, k, d) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; k &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; d.value &#x3D;&#x3D;&#x3D; 5;
        return true;
      }
    }),
    &quot;foo&quot;,
    { value: 5, configurable: true }
  );
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;defineProperty&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // A property cannot be added, if the target object is not extensible.
  var proxied &#x3D; Object.preventExtensions({});
  var proxy &#x3D; new Proxy(proxied, {
    defineProperty: function() {
      passed &#x3D; true;
      return true;
    }
  });
  try {
    Object.defineProperty(proxy, &quot;foo&quot;, { value: 2 });
    return false;
  } catch(e) {}
  // A property cannot be non-configurable, unless there exists a corresponding
  // non-configurable own property of the target object.
  try {
    Object.defineProperty(
      new Proxy({ bar: true }, {
        defineProperty: function () {
          return true;
        }
      }),
      &quot;bar&quot;,
      { value: 5, configurable: false, writable: true, enumerable: true }
    );
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;getPrototypeOf&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var fakeProto &#x3D; {};
  var proxy &#x3D; new Proxy(proxied, {
    getPrototypeOf: function (t) {
      return t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; fakeProto;
    }
  });
  return Object.getPrototypeOf(proxy) &#x3D;&#x3D;&#x3D; fakeProto;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;getPrototypeOf&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // If the target object is not extensible, [[GetPrototypeOf]] applied to the proxy object
  // must return the same value as [[GetPrototypeOf]] applied to the proxy object&#x27;s target object.
  try {
    Object.getPrototypeOf(new Proxy(Object.preventExtensions({}), {
      getPrototypeOf: function () {
        passed &#x3D; true;
        return {};
      }
    }));
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;setPrototypeOf&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var newProto &#x3D; {};
  var passed &#x3D; false;
  Object.setPrototypeOf(
    new Proxy(proxied, {
      setPrototypeOf: function (t, p) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; p &#x3D;&#x3D;&#x3D; newProto;
        return true;
      }
    }),
    newProto
  );
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;setPrototypeOf&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  Object.setPrototypeOf({},{});
  // If the target object is not extensible, the argument value must be the
  // same as the result of [[GetPrototypeOf]] applied to target object.
  try {
    Object.setPrototypeOf(
      new Proxy(Object.preventExtensions({}), {
        setPrototypeOf: function () {
          passed &#x3D; true;
          return true;
        }
      }),{});
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;isExtensible&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  Object.isExtensible(
    new Proxy(proxied, {
      isExtensible: function (t) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied; return true;
      }
    })
  );
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;isExtensible&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // [[IsExtensible]] applied to the proxy object must return the same value
  // as [[IsExtensible]] applied to the proxy object&#x27;s target object with the same argument.
  try {
    Object.isExtensible(new Proxy({}, {
      isExtensible: function (t) {
        passed &#x3D; true;
        return false;
      }
    }));
    return false;
  } catch(e) {}
  try {
    Object.isExtensible(new Proxy(Object.preventExtensions({}), {
      isExtensible: function (t) {
        return true;
      }
    }));
    return false;
  } catch(e) {}
  return true;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;preventExtensions&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  Object.preventExtensions(
    new Proxy(proxied, {
      preventExtensions: function (t) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied;
        return Object.preventExtensions(proxied);
      }
    })
  );
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;preventExtensions&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // [[PreventExtensions]] applied to the proxy object only returns true
  // if [[IsExtensible]] applied to the proxy object&#x27;s target object is false.
  try {
    Object.preventExtensions(new Proxy({}, {
      preventExtensions: function () {
        passed &#x3D; true;
        return true;
      }
    }));
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;ownKeys&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; {};
  var passed &#x3D; false;
  Object.keys(
    new Proxy(proxied, {
      ownKeys: function (t) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied; return [];
      }
    })
  );
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;ownKeys&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // The Type of each result List element is either String or Symbol.
  try {
    Object.keys(new Proxy({}, {
      ownKeys: function () {
        passed &#x3D; true;
        return [2];
      }}));
    return false;
  } catch(e) {}
  // The result List must contain the keys of all non-configurable own properties of the target object.
  var proxied &#x3D; {};
  Object.defineProperty(proxied, &quot;foo&quot;, { value: 2, writable: true, enumerable: true });
  try {
    Object.keys(new Proxy(proxied, {
      ownKeys: function () {
        return [];
      }}));
    return false;
  } catch(e) {}
  // If the target object is not extensible, then the result List must contain all the keys
  // of the own properties of the target object and no other values.
  try {
    Object.keys(new Proxy(Object.preventExtensions({b:1}), {
      ownKeys: function () {
        return [&#x27;a&#x27;];
      }}));
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;apply&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; function(){};
  var passed &#x3D; false;
  var host &#x3D; {
    method: new Proxy(proxied, {
      apply: function (t, thisArg, args) {
        passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; thisArg &#x3D;&#x3D;&#x3D; host &amp;&amp; args + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
      }
    })
  };
  host.method(&quot;foo&quot;, &quot;bar&quot;);
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;apply&quot; handler invariant
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy(function(){}, {
      apply: function () { passed &#x3D; true; }
  })();
  // A Proxy exotic object only has a [[Call]] internal method if the
  // initial value of its [[ProxyTarget]] internal slot is an object
  // that has a [[Call]] internal method.
  try {
    new Proxy({}, {
      apply: function () {}
    })();
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;construct&quot; handler
                    <pre><code>(function (){
  var proxied &#x3D; function(){};
  var passed &#x3D; false;
  new new Proxy(proxied, {
    construct: function (t, args) {
      passed &#x3D; t &#x3D;&#x3D;&#x3D; proxied &amp;&amp; args + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
      return {};
    }
  })(&quot;foo&quot;,&quot;bar&quot;);
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - &quot;construct&quot; handler invariants
                    <pre><code>(function (){
  var passed &#x3D; false;
  new Proxy({},{});
  // A Proxy exotic object only has a [[Construct]] internal method if the
  // initial value of its [[ProxyTarget]] internal slot is an object
  // that has a [[Construct]] internal method.
  try {
    new new Proxy({}, {
      construct: function (t, args) {
        return {};
      }
    })();
    return false;
  } catch(e) {}
  // The result of [[Construct]] must be an Object.
  try {
    new new Proxy(function(){}, {
      construct: function (t, args) {
        passed &#x3D; true;
        return 5;
      }
    })();
    return false;
  } catch(e) {}
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Proxy.revocable
                    <pre><code>(function (){
  var obj &#x3D; Proxy.revocable({}, { get: function() { return 5; } });
  var passed &#x3D; (obj.proxy.foo &#x3D;&#x3D;&#x3D; 5);
  obj.revoke();
  try {
    obj.proxy.foo;
  } catch(e) {
    passed &amp;&#x3D; e instanceof TypeError;
  }
  return passed;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.isArray support
                    <pre><code>(function (){
  return Array.isArray(new Proxy([], {}));
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - JSON.stringify support
                    <pre><code>(function (){
  return JSON.stringify(new Proxy([&#x27;foo&#x27;], {})) &#x3D;&#x3D;&#x3D; &#x27;[&quot;foo&quot;]&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Reflect

              <ul>
                <li>
                  FAIL - Reflect.get
                    <pre><code>(function (){
  return Reflect.get({ qux: 987 }, &quot;qux&quot;) &#x3D;&#x3D;&#x3D; 987;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.set
                    <pre><code>(function (){
  var obj &#x3D; {};
  Reflect.set(obj, &quot;quux&quot;, 654);
  return obj.quux &#x3D;&#x3D;&#x3D; 654;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.has
                    <pre><code>(function (){
  return Reflect.has({ qux: 987 }, &quot;qux&quot;);
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.deleteProperty
                    <pre><code>(function (){
  var obj &#x3D; { bar: 456 };
  Reflect.deleteProperty(obj, &quot;bar&quot;);
  return !(&quot;bar&quot; in obj);
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getOwnPropertyDescriptor
                    <pre><code>(function (){
  var obj &#x3D; { baz: 789 };
  var desc &#x3D; Reflect.getOwnPropertyDescriptor(obj, &quot;baz&quot;);
  return desc.value &#x3D;&#x3D;&#x3D; 789 &amp;&amp;
    desc.configurable &amp;&amp; desc.writable &amp;&amp; desc.enumerable;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.defineProperty
                    <pre><code>(function (){
  var obj &#x3D; {};
  Reflect.defineProperty(obj, &quot;foo&quot;, { value: 123 });
  return obj.foo &#x3D;&#x3D;&#x3D; 123 &amp;&amp;
    Reflect.defineProperty(Object.freeze({}), &quot;foo&quot;, { value: 123 }) &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getPrototypeOf
                    <pre><code>(function (){
  return Reflect.getPrototypeOf([]) &#x3D;&#x3D;&#x3D; Array.prototype;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.setPrototypeOf
                    <pre><code>(function (){
  var obj &#x3D; {};
  Reflect.setPrototypeOf(obj, Array.prototype);
  return obj instanceof Array;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.isExtensible
                    <pre><code>(function (){
  return Reflect.isExtensible({}) &amp;&amp;
    !Reflect.isExtensible(Object.preventExtensions({}));
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.preventExtensions
                    <pre><code>(function (){
  var obj &#x3D; {};
  Reflect.preventExtensions(obj);
  return !Object.isExtensible(obj);
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.ownKeys, string keys
                    <pre><code>(function (){
  var obj &#x3D; Object.create({ C: true });
  obj.A &#x3D; true;
  Object.defineProperty(obj, &#x27;B&#x27;, { value: true, enumerable: false });

  return Reflect.ownKeys(obj).sort() + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;A,B&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.ownKeys, symbol keys
                    <pre><code>(function (){
  var s1 &#x3D; Symbol(), s2 &#x3D; Symbol(), s3 &#x3D; Symbol();
  var proto &#x3D; {};
  proto[s1] &#x3D; true;
  var obj &#x3D; Object.create(proto);
  obj[s2] &#x3D; true;
  Object.defineProperty(obj, s3, { value: true, enumerable: false });

  var keys &#x3D; Reflect.ownKeys(obj);
  return keys.indexOf(s2) &gt;-1 &amp;&amp; keys.indexOf(s3) &gt;-1 &amp;&amp; keys.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.apply
                    <pre><code>(function (){
  return Reflect.apply(Array.prototype.push, [1,2], [3,4,5]) &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.construct
                    <pre><code>(function (){
  return Reflect.construct(function(a, b, c) {
    this.qux &#x3D; a + b + c;
  }, [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]).qux &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.construct sets new.target meta property
                    <pre><code>(function (){
  return Reflect.construct(function(a, b, c) {
    if (new.target &#x3D;&#x3D;&#x3D; Object) {
      this.qux &#x3D; a + b + c;
    }
  }, [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;], Object).qux &#x3D;&#x3D;&#x3D; &quot;foobarbaz&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.construct creates instance from newTarget argument
                    <pre><code>(function (){
  function F(){}
  return Reflect.construct(function(){}, [], F) instanceof F;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Promise

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var p1 &#x3D; new Promise(function(resolve, reject) { resolve(&quot;foo&quot;); });
  var p2 &#x3D; new Promise(function(resolve, reject) { reject(&quot;quux&quot;); });
  var score &#x3D; 0;

  function thenFn(result)  { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;foo&quot;);  check(); }
  function catchFn(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;quux&quot;); check(); }
  function shouldNotRun(result)  { score &#x3D; -Infinity;   }

  p1.then(thenFn, shouldNotRun);
  p2.then(shouldNotRun, catchFn);
  p1.catch(shouldNotRun);
  p2.catch(catchFn);

  p1.then(function() {
    // Promise.prototype.then() should return a new Promise
    score +&#x3D; p1.then() !&#x3D;&#x3D; p1;
    check();
  });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 4) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: true</span>
                </li>
                <li>
                  SUCCESS - constructor requires new
                    <pre><code>(function (){
  new Promise(function(){});
  try {
    Promise(function(){});
    return false;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Promise.prototype isn&#x27;t an instance
                    <pre><code>(function (){
  new Promise(function(){});
  try {
    Promise.prototype.then(function(){});
  } catch (e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Promise.all
                    <pre><code>(function (){
  var fulfills &#x3D; Promise.all([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,100,&quot;bar&quot;); }),
  ]);
  var rejects &#x3D; Promise.all([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 100,&quot;qux&quot;); }),
  ]);
  var score &#x3D; 0;
  fulfills.then(function(result) { score +&#x3D; (result + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;qux&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 2) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: true</span>
                </li>
                <li>
                  FAIL - Promise.all, generic iterables
                    <pre><code>(function (){
  var fulfills &#x3D; Promise.all(global.__createIterableObject([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,100,&quot;bar&quot;); }),
  ]));
  var rejects &#x3D; Promise.all(global.__createIterableObject([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 100,&quot;qux&quot;); }),
  ]));
  var score &#x3D; 0;
  fulfills.then(function(result) { score +&#x3D; (result + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;qux&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 2) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: true</span>
                </li>
                <li>
                  SUCCESS - Promise.race
                    <pre><code>(function (){
  var fulfills &#x3D; Promise.race([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 300,&quot;bar&quot;); }),
  ]);
  var rejects &#x3D; Promise.race([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,300,&quot;qux&quot;); }),
  ]);
  var score &#x3D; 0;
  fulfills.then(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;foo&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;baz&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 2) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: true</span>
                </li>
                <li>
                  FAIL - Promise.race, generic iterables
                    <pre><code>(function (){
  var fulfills &#x3D; Promise.race(global.__createIterableObject([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 300,&quot;bar&quot;); }),
  ]));
  var rejects &#x3D; Promise.race(global.__createIterableObject([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,300,&quot;qux&quot;); }),
  ]));
  var score &#x3D; 0;
  fulfills.then(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;foo&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;baz&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 2) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: true</span>
                </li>
                <li>
                  FAIL - Promise[Symbol.species]
                    <pre><code>(function (){
  var prop &#x3D; Object.getOwnPropertyDescriptor(Promise, Symbol.species);
  return &#x27;get&#x27; in prop &amp;&amp; Promise[Symbol.species] &#x3D;&#x3D;&#x3D; Promise;
})()</code></pre>
                    <span>Result: TypeError: Cannot use &#x27;in&#x27; operator to search for &#x27;get&#x27; in undefined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Symbol

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  var object &#x3D; {};
  var symbol &#x3D; Symbol();
  var value &#x3D; {};
  object[symbol] &#x3D; value;
  return object[symbol] &#x3D;&#x3D;&#x3D; value;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - typeof support
                    <pre><code>(function (){
  return typeof Symbol() &#x3D;&#x3D;&#x3D; &quot;symbol&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - symbol keys are hidden to pre-ES6 code
                    <pre><code>(function (){
  var object &#x3D; {};
  var symbol &#x3D; Symbol();
  object[symbol] &#x3D; 1;

  for (var x in object){}
  var passed &#x3D; !x;

  if (Object.keys &amp;&amp; Object.getOwnPropertyNames) {
    passed &amp;&#x3D; Object.keys(object).length &#x3D;&#x3D;&#x3D; 0
      &amp;&amp; Object.getOwnPropertyNames(object).length &#x3D;&#x3D;&#x3D; 0;
  }

  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.defineProperty support
                    <pre><code>(function (){
  var object &#x3D; {};
  var symbol &#x3D; Symbol();
  var value &#x3D; {};

  if (Object.defineProperty) {
    Object.defineProperty(object, symbol, { value: value });
    return object[symbol] &#x3D;&#x3D;&#x3D; value;
  }

  return passed;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - symbols inherit from Symbol.prototype
                    <pre><code>(function (){
  var symbol &#x3D; Symbol();
  var passed &#x3D; symbol.foo &#x3D;&#x3D;&#x3D; undefined;
  Symbol.prototype.foo &#x3D; 2;
  passed &amp;&#x3D; symbol.foo &#x3D;&#x3D;&#x3D; 2;
  delete Symbol.prototype.foo;
  return passed;
})()</code></pre>
                    <span>Result: 1</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - cannot coerce to string or number
                    <pre><code>(function (){
  var symbol &#x3D; Symbol();

  try {
    symbol + &quot;&quot;;
    return false;
  }
  catch(e) {}

  try {
    symbol + 0;
    return false;
  } catch(e) {}

  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - can convert with String()
                    <pre><code>(function (){
  return String(Symbol(&quot;foo&quot;)) &#x3D;&#x3D;&#x3D; &quot;Symbol(foo)&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - new Symbol() throws
                    <pre><code>(function (){
  var symbol &#x3D; Symbol();
  try {
    new Symbol();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object(symbol)
                    <pre><code>(function (){
  var symbol &#x3D; Symbol();
  var symbolObject &#x3D; Object(symbol);

  return typeof symbolObject &#x3D;&#x3D;&#x3D; &quot;object&quot; &amp;&amp;
    symbolObject instanceof Symbol &amp;&amp;
    symbolObject &#x3D;&#x3D; symbol &amp;&amp;
    symbolObject !&#x3D;&#x3D; symbol &amp;&amp;
    symbolObject.valueOf() &#x3D;&#x3D;&#x3D; symbol;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - JSON.stringify ignores symbols
                    <pre><code>(function (){
  var object &#x3D; {foo: Symbol()};
  object[Symbol()] &#x3D; 1;
  var array &#x3D; [Symbol()];
  return JSON.stringify(object) &#x3D;&#x3D;&#x3D; &#x27;{}&#x27; &amp;&amp; JSON.stringify(array) &#x3D;&#x3D;&#x3D; &#x27;[null]&#x27; &amp;&amp; JSON.stringify(Symbol()) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - global symbol registry
                    <pre><code>(function (){
  var symbol &#x3D; Symbol.for(&#x27;foo&#x27;);
  return Symbol.for(&#x27;foo&#x27;) &#x3D;&#x3D;&#x3D; symbol &amp;&amp;
     Symbol.keyFor(symbol) &#x3D;&#x3D;&#x3D; &#x27;foo&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - well-known symbols

              <ul>
                <li>
                  FAIL - Symbol.hasInstance
                    <pre><code>(function (){
  var passed &#x3D; false;
  var obj &#x3D; { foo: true };
  var C &#x3D; function(){};
  Object.defineProperty(C, Symbol.hasInstance, {
    value: function(inst) { passed &#x3D; inst.foo; return false; }
  });
  obj instanceof C;
  return passed;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.isConcatSpreadable
                    <pre><code>(function (){
  var a &#x3D; [], b &#x3D; [];
  b[Symbol.isConcatSpreadable] &#x3D; false;
  a &#x3D; a.concat(b);
  return a[0] &#x3D;&#x3D;&#x3D; b;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Symbol.iterator, existence
                    <pre><code>(function (){
  return &quot;iterator&quot; in Symbol;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Symbol.iterator, arguments object
                    <pre><code>(function (){
  return (function() {
    return typeof arguments[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
      &amp;&amp; Object.hasOwnProperty.call(arguments, Symbol.iterator);
  }());
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, existence
                    <pre><code>(function (){
  return &quot;species&quot; in Symbol;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Array.prototype.concat
                    <pre><code>(function (){
  var obj &#x3D; [];
  obj.constructor &#x3D; {};
  obj.constructor[Symbol.species] &#x3D; function() {
      return { foo: 1 };
  };
  return Array.prototype.concat.call(obj, []).foo &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Array.prototype.filter
                    <pre><code>(function (){
  var obj &#x3D; [];
  obj.constructor &#x3D; {};
  obj.constructor[Symbol.species] &#x3D; function() {
      return { foo: 1 };
  };
  return Array.prototype.filter.call(obj, Boolean).foo &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Array.prototype.map
                    <pre><code>(function (){
  var obj &#x3D; [];
  obj.constructor &#x3D; {};
  obj.constructor[Symbol.species] &#x3D; function() {
      return { foo: 1 };
  };
  return Array.prototype.map.call(obj, Boolean).foo &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Array.prototype.slice
                    <pre><code>(function (){
  var obj &#x3D; [];
  obj.constructor &#x3D; {};
  obj.constructor[Symbol.species] &#x3D; function() {
      return { foo: 1 };
  };
  return Array.prototype.slice.call(obj, 0).foo &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Array.prototype.splice
                    <pre><code>(function (){
  var obj &#x3D; [];
  obj.constructor &#x3D; {};
  obj.constructor[Symbol.species] &#x3D; function() {
      return { foo: 1 };
  };
  return Array.prototype.splice.call(obj, 0).foo &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, RegExp.prototype[Symbol.split]
                    <pre><code>(function (){
  var passed &#x3D; false;
  var obj &#x3D; { constructor: {} };
  obj[Symbol.split] &#x3D; RegExp.prototype[Symbol.split];
  obj.constructor[Symbol.species] &#x3D; function() {
    passed &#x3D; true;
    return /./;
  };
  &quot;&quot;.split(obj);
  return passed;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.species, Promise.prototype.then
                    <pre><code>(function (){
  var promise      &#x3D; new Promise(function(resolve){ resolve(42); });
  var FakePromise1 &#x3D; promise.constructor &#x3D; function(exec){ exec(function(){}, function(){}); };
  var FakePromise2 &#x3D; function(exec){ exec(function(){}, function(){}); };
  Object.defineProperty(FakePromise1, Symbol.species, {value: FakePromise2});
  return promise.then(function(){}) instanceof FakePromise2;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.replace
                    <pre><code>(function (){
  var O &#x3D; {};
  O[Symbol.replace] &#x3D; function(){
    return 42;
  };
  return &#x27;&#x27;.replace(O) &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.search
                    <pre><code>(function (){
  var O &#x3D; {};
  O[Symbol.search] &#x3D; function(){
    return 42;
  };
  return &#x27;&#x27;.search(O) &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.split
                    <pre><code>(function (){
  var O &#x3D; {};
  O[Symbol.split] &#x3D; function(){
    return 42;
  };
  return &#x27;&#x27;.split(O) &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.match
                    <pre><code>(function (){
  var O &#x3D; {};
  O[Symbol.match] &#x3D; function(){
    return 42;
  };
  return &#x27;&#x27;.match(O) &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.match, RegExp constructor
                    <pre><code>(function (){
  var re &#x3D; /./;
  re[Symbol.match] &#x3D; false;
  var foo &#x3D; {constructor: RegExp};
  foo[Symbol.match] &#x3D; true;
  return RegExp(re) !&#x3D;&#x3D; re &amp;&amp; RegExp(foo) &#x3D;&#x3D;&#x3D; foo;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.match, String.prototype.startsWith
                    <pre><code>(function (){
  var re &#x3D; /./;
  try {
    &#x27;/./&#x27;.startsWith(re);
  } catch(e){
    re[Symbol.match] &#x3D; false;
    return &#x27;/./&#x27;.startsWith(re);
  }
})()</code></pre>
                    <span>Result: TypeError: First argument to String.prototype.startsWith must not be a regular expression</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.match, String.prototype.endsWith
                    <pre><code>(function (){
  var re &#x3D; /./;
  try {
    &#x27;/./&#x27;.endsWith(re);
  } catch(e){
    re[Symbol.match] &#x3D; false;
    return &#x27;/./&#x27;.endsWith(re);
  }
})()</code></pre>
                    <span>Result: TypeError: First argument to String.prototype.endsWith must not be a regular expression</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.match, String.prototype.includes
                    <pre><code>(function (){
  var re &#x3D; /./;
  try {
    &#x27;/./&#x27;.includes(re);
  } catch(e){
    re[Symbol.match] &#x3D; false;
    return &#x27;/./&#x27;.includes(re);
  }
})()</code></pre>
                    <span>Result: TypeError: First argument to String.prototype.includes must not be a regular expression</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.toPrimitive
                    <pre><code>(function (){
  var a &#x3D; {}, b &#x3D; {}, c &#x3D; {};
  var passed &#x3D; 0;
  a[Symbol.toPrimitive] &#x3D; function(hint) { passed +&#x3D; hint &#x3D;&#x3D;&#x3D; &quot;number&quot;;  return 0; };
  b[Symbol.toPrimitive] &#x3D; function(hint) { passed +&#x3D; hint &#x3D;&#x3D;&#x3D; &quot;string&quot;;  return 0; };
  c[Symbol.toPrimitive] &#x3D; function(hint) { passed +&#x3D; hint &#x3D;&#x3D;&#x3D; &quot;default&quot;; return 0; };

  a &gt;&#x3D; 0;
  b in {};
  c &#x3D;&#x3D; 0;
  return passed &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.toStringTag
                    <pre><code>(function (){
  var a &#x3D; {};
  a[Symbol.toStringTag] &#x3D; &quot;foo&quot;;
  return (a + &quot;&quot;) &#x3D;&#x3D;&#x3D; &quot;[object foo]&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.toStringTag affects existing built-ins
                    <pre><code>(function (){
  var s &#x3D; Symbol.toStringTag;
  var passed &#x3D; true;
  [
    [Array.prototype, []],
    [String.prototype, &#x27;&#x27;],
    [arguments, arguments],
    [Function.prototype, function(){}],
    [Error.prototype, new Error()],
    [Boolean.prototype, true],
    [Number.prototype, 2],
    [Date.prototype, new Date()],
    [RegExp.prototype, /./]
  ].forEach(function(pair){
    pair[0][s] &#x3D; &quot;foo&quot;;
    passed &amp;&#x3D; (Object.prototype.toString.call(pair[1]) &#x3D;&#x3D;&#x3D; &quot;[object foo]&quot;);
    delete pair[0][s];
  });
  return passed;
})()</code></pre>
                    <span>Result: 0</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.toStringTag, new built-ins
                    <pre><code>(function (){
  var passed &#x3D; true;
  var s &#x3D; Symbol.toStringTag;
  [
    [String, &quot;String Iterator&quot;],
    [Array, &quot;Array Iterator&quot;],
    [Map, &quot;Map Iterator&quot;],
    [Set, &quot;Set Iterator&quot;]
  ].forEach(function(pair){
    var iterProto &#x3D; Object.getPrototypeOf(new pair[0]()[Symbol.iterator]());
    passed &#x3D; passed
      &amp;&amp; iterProto.hasOwnProperty(s)
      &amp;&amp; iterProto[s] &#x3D;&#x3D;&#x3D; pair[1];
  });
  passed &#x3D; passed
    &amp;&amp; Object.getPrototypeOf(function*(){})[s] &#x3D;&#x3D;&#x3D; &quot;GeneratorFunction&quot;
    &amp;&amp; Object.getPrototypeOf(function*(){}())[s] &#x3D;&#x3D;&#x3D; &quot;Generator&quot;
    &amp;&amp; Map.prototype[s] &#x3D;&#x3D;&#x3D; &quot;Map&quot;
    &amp;&amp; Set.prototype[s] &#x3D;&#x3D;&#x3D; &quot;Set&quot;
    &amp;&amp; ArrayBuffer.prototype[s] &#x3D;&#x3D;&#x3D; &quot;ArrayBuffer&quot;
    &amp;&amp; DataView.prototype[s] &#x3D;&#x3D;&#x3D; &quot;DataView&quot;
    &amp;&amp; Promise.prototype[s] &#x3D;&#x3D;&#x3D; &quot;Promise&quot;
    &amp;&amp; Symbol.prototype[s] &#x3D;&#x3D;&#x3D; &quot;Symbol&quot;
    &amp;&amp; typeof Object.getOwnPropertyDescriptor(
      Object.getPrototypeOf(Int8Array).prototype, Symbol.toStringTag).get &#x3D;&#x3D;&#x3D; &quot;function&quot;;
    return passed;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.toStringTag, misc. built-ins
                    <pre><code>(function (){
  var s &#x3D; Symbol.toStringTag;
  return Math[s] &#x3D;&#x3D;&#x3D; &quot;Math&quot;
    &amp;&amp; JSON[s] &#x3D;&#x3D;&#x3D; &quot;JSON&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Symbol.unscopables
                    <pre><code>(function (){
  var a &#x3D; { foo: 1, bar: 2 };
  a[Symbol.unscopables] &#x3D; { bar: true };
  with (a) {
    return foo &#x3D;&#x3D;&#x3D; 1 &amp;&amp; typeof bar &#x3D;&#x3D;&#x3D; &quot;undefined&quot;;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Object static methods

              <ul>
                <li>
                  SUCCESS - Object.assign
                    <pre><code>(function (){
  var o &#x3D; Object.assign({a:true}, {b:true}, {c:true});
  return &quot;a&quot; in o &amp;&amp; &quot;b&quot; in o &amp;&amp; &quot;c&quot; in o;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.is
                    <pre><code>(function (){
  return typeof Object.is &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp;
    Object.is(NaN, NaN) &amp;&amp;
   !Object.is(-0, 0);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getOwnPropertySymbols
                    <pre><code>(function (){
  var o &#x3D; {};
  var sym &#x3D; Symbol(), sym2 &#x3D; Symbol(), sym3 &#x3D; Symbol();
  o[sym]  &#x3D; true;
  o[sym2] &#x3D; true;
  o[sym3] &#x3D; true;
  var result &#x3D; Object.getOwnPropertySymbols(o);
  return result[0] &#x3D;&#x3D;&#x3D; sym
    &amp;&amp; result[1] &#x3D;&#x3D;&#x3D; sym2
    &amp;&amp; result[2] &#x3D;&#x3D;&#x3D; sym3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.setPrototypeOf
                    <pre><code>(function (){
  return Object.setPrototypeOf({}, Array.prototype) instanceof Array;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - function &quot;name&quot; property

              <ul>
                <li>
                  SUCCESS - function statements
                    <pre><code>(function (){
  function foo(){};
  return foo.name &#x3D;&#x3D;&#x3D; &#x27;foo&#x27; &amp;&amp;
    (function(){}).name &#x3D;&#x3D;&#x3D; &#x27;&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - function expressions
                    <pre><code>(function (){
  return (function foo(){}).name &#x3D;&#x3D;&#x3D; &#x27;foo&#x27; &amp;&amp;
    (function(){}).name &#x3D;&#x3D;&#x3D; &#x27;&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - new Function
                    <pre><code>(function (){
  return (new Function).name &#x3D;&#x3D;&#x3D; &quot;anonymous&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - bound functions
                    <pre><code>(function (){
  function foo() {};
  return foo.bind({}).name &#x3D;&#x3D;&#x3D; &quot;bound foo&quot; &amp;&amp;
    (function(){}).bind({}).name &#x3D;&#x3D;&#x3D; &quot;bound &quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - variables (function)
                    <pre><code>(function (){
  var foo &#x3D; function() {};
  var bar &#x3D; function baz() {};
  return foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; bar.name &#x3D;&#x3D;&#x3D; &quot;baz&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object methods (function)
                    <pre><code>(function (){
  var o &#x3D; { foo: function(){}, bar: function baz(){}};
  o.qux &#x3D; function(){};
  return o.foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp;
         o.bar.name &#x3D;&#x3D;&#x3D; &quot;baz&quot; &amp;&amp;
         o.qux.name &#x3D;&#x3D;&#x3D; &quot;&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - accessor properties
                    <pre><code>(function (){
  var o &#x3D; { get foo(){}, set foo(x){} };
  var descriptor &#x3D; Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);
  return descriptor.get.name &#x3D;&#x3D;&#x3D; &quot;get foo&quot; &amp;&amp;
         descriptor.set.name &#x3D;&#x3D;&#x3D; &quot;set foo&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand methods
                    <pre><code>(function (){
  var o &#x3D; { foo(){} };
  return o.foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - shorthand methods (no lexical binding)
                    <pre><code>(function (){
  var f &#x3D; &quot;foo&quot;;
  return ({f() { return f; }}).f() &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - symbol-keyed methods
                    <pre><code>(function (){
  var sym1 &#x3D; Symbol(&quot;foo&quot;);
  var sym2 &#x3D; Symbol();
  var o &#x3D; {
    [sym1]: function(){},
    [sym2]: function(){}
  };

  return o[sym1].name &#x3D;&#x3D;&#x3D; &quot;[foo]&quot; &amp;&amp;
         o[sym2].name &#x3D;&#x3D;&#x3D; &quot;&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class statements
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class foo {};
  class bar { static name() {} };
  return foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp;
    typeof bar.name &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class expressions
                    <pre><code>(function (){
  &quot;use strict&quot;;
  return class foo {}.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp;
    typeof class bar { static name() {} }.name &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - variables (class)
                    <pre><code>(function (){
  var foo &#x3D; class {};
  var bar &#x3D; class baz {};
  var qux &#x3D; class { static name() {} };
  return foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp;
         bar.name &#x3D;&#x3D;&#x3D; &quot;baz&quot; &amp;&amp;
         typeof qux.name &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - object methods (class)
                    <pre><code>(function (){
  var o &#x3D; { foo: class {}, bar: class baz {}};
  o.qux &#x3D; class {};
  return o.foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp;
         o.bar.name &#x3D;&#x3D;&#x3D; &quot;baz&quot; &amp;&amp;
         o.qux.name &#x3D;&#x3D;&#x3D; &quot;&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class prototype methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C { foo(){} };
  return (new C).foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - class static methods
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C { static foo(){} };
  return C.foo.name &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - isn&#x27;t writable, is configurable
                    <pre><code>(function (){
  var descriptor &#x3D; Object.getOwnPropertyDescriptor(function f(){},&quot;name&quot;);
  return descriptor.enumerable   &#x3D;&#x3D;&#x3D; false &amp;&amp;
         descriptor.writable     &#x3D;&#x3D;&#x3D; false &amp;&amp;
         descriptor.configurable &#x3D;&#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - String static methods

              <ul>
                <li>
                  SUCCESS - String.raw
                    <pre><code>(function (){
  return typeof String.raw &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.fromCodePoint
                    <pre><code>(function (){
  return typeof String.fromCodePoint &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - String.prototype methods

              <ul>
                <li>
                  SUCCESS - String.prototype.codePointAt
                    <pre><code>(function (){
  return typeof String.prototype.codePointAt &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.normalize
                    <pre><code>(function (){
  return typeof String.prototype.normalize &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; &quot;c\u0327\u0301&quot;.normalize(&quot;NFC&quot;) &#x3D;&#x3D;&#x3D; &quot;\u1e09&quot;
    &amp;&amp; &quot;\u1e09&quot;.normalize(&quot;NFD&quot;) &#x3D;&#x3D;&#x3D; &quot;c\u0327\u0301&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.repeat
                    <pre><code>(function (){
  return typeof String.prototype.repeat &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
    &amp;&amp; &quot;foo&quot;.repeat(3) &#x3D;&#x3D;&#x3D; &quot;foofoofoo&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.startsWith
                    <pre><code>(function (){
  return typeof String.prototype.startsWith &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
    &amp;&amp; &quot;foobar&quot;.startsWith(&quot;foo&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.endsWith
                    <pre><code>(function (){
  return typeof String.prototype.endsWith &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
    &amp;&amp; &quot;foobar&quot;.endsWith(&quot;bar&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.includes
                    <pre><code>(function (){
  return typeof String.prototype.includes &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
    &amp;&amp; &quot;foobar&quot;.includes(&quot;oba&quot;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype[Symbol.iterator]
                    <pre><code>(function (){
  return typeof String.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String iterator prototype chain
                    <pre><code>(function (){
  // Iterator instance
  var iterator &#x3D; &#x27;&#x27;[Symbol.iterator]();
  // %StringIteratorPrototype%
  var proto1 &#x3D; Object.getPrototypeOf(iterator);
  // %IteratorPrototype%
  var proto2 &#x3D; Object.getPrototypeOf(proto1);

  return proto2.hasOwnProperty(Symbol.iterator) &amp;&amp;
    !proto1    .hasOwnProperty(Symbol.iterator) &amp;&amp;
    !iterator  .hasOwnProperty(Symbol.iterator) &amp;&amp;
    iterator[Symbol.iterator]() &#x3D;&#x3D;&#x3D; iterator;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - RegExp.prototype properties

              <ul>
                <li>
                  FAIL - RegExp.prototype.flags
                    <pre><code>(function (){
  return /./igm.flags &#x3D;&#x3D;&#x3D; &quot;gim&quot; &amp;&amp; /./.flags &#x3D;&#x3D;&#x3D; &quot;&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.match]
                    <pre><code>(function (){
  return typeof RegExp.prototype[Symbol.match] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.replace]
                    <pre><code>(function (){
  return typeof RegExp.prototype[Symbol.replace] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.split]
                    <pre><code>(function (){
  return typeof RegExp.prototype[Symbol.split] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.search]
                    <pre><code>(function (){
  return typeof RegExp.prototype[Symbol.search] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp[Symbol.species]
                    <pre><code>(function (){
  var prop &#x3D; Object.getOwnPropertyDescriptor(RegExp, Symbol.species);
  return &#x27;get&#x27; in prop &amp;&amp; RegExp[Symbol.species] &#x3D;&#x3D;&#x3D; RegExp;
})()</code></pre>
                    <span>Result: TypeError: Cannot use &#x27;in&#x27; operator to search for &#x27;get&#x27; in undefined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Array static methods

              <ul>
                <li>
                  SUCCESS - Array.from, array-like objects
                    <pre><code>(function (){
  return Array.from({ 0: &quot;foo&quot;, 1: &quot;bar&quot;, length: 2 }) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.from, generator instances
                    <pre><code>(function (){
  var iterable &#x3D; (function*(){ yield 1; yield 2; yield 3; }());
  return Array.from(iterable) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;1,2,3&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from, generic iterables
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  return Array.from(iterable) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;1,2,3&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from, instances of generic iterables
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([1, 2, 3]);
  return Array.from(Object.create(iterable)) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;1,2,3&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.from map function, array-like objects
                    <pre><code>(function (){
  return Array.from({ 0: &quot;foo&quot;, 1: &quot;bar&quot;, length: 2 }, function(e, i) {
    return e + this.baz + i;
  }, { baz: &quot;d&quot; }) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;food0,bard1&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.from map function, generator instances
                    <pre><code>(function (){
  var iterable &#x3D; (function*(){ yield &quot;foo&quot;; yield &quot;bar&quot;; yield &quot;bal&quot;; }());
  return Array.from(iterable, function(e, i) {
    return e + this.baz + i;
  }, { baz: &quot;d&quot; }) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;food0,bard1,bald2&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from map function, generic iterables
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([&quot;foo&quot;, &quot;bar&quot;, &quot;bal&quot;]);
  return Array.from(iterable, function(e, i) {
    return e + this.baz + i;
  }, { baz: &quot;d&quot; }) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;food0,bard1,bald2&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from map function, instances of iterables
                    <pre><code>(function (){
  var iterable &#x3D; global.__createIterableObject([&quot;foo&quot;, &quot;bar&quot;, &quot;bal&quot;]);
  return Array.from(Object.create(iterable), function(e, i) {
    return e + this.baz + i;
  }, { baz: &quot;d&quot; }) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;food0,bard1,bald2&quot;;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from, iterator closing
                    <pre><code>(function (){
  var closed &#x3D; false;
  var iter &#x3D; global.__createIterableObject([1, 2, 3], {
    &#x27;return&#x27;: function(){ closed &#x3D; true; return {}; }
  });
  try {
    Array.from(iter, function() { throw 42 });
  } catch(e){}
  return closed;
})()</code></pre>
                    <span>Result: TypeError: global.__createIterableObject is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.of
                    <pre><code>(function (){
  return typeof Array.of &#x3D;&#x3D;&#x3D; &#x27;function&#x27; &amp;&amp;
    Array.of(2)[0] &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array[Symbol.species]
                    <pre><code>(function (){
  var prop &#x3D; Object.getOwnPropertyDescriptor(Array, Symbol.species);
  return &#x27;get&#x27; in prop &amp;&amp; Array[Symbol.species] &#x3D;&#x3D;&#x3D; Array;
})()</code></pre>
                    <span>Result: TypeError: Cannot use &#x27;in&#x27; operator to search for &#x27;get&#x27; in undefined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Array.prototype methods

              <ul>
                <li>
                  SUCCESS - Array.prototype.copyWithin
                    <pre><code>(function (){
  return typeof Array.prototype.copyWithin &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.find
                    <pre><code>(function (){
  return typeof Array.prototype.find &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.findIndex
                    <pre><code>(function (){
  return typeof Array.prototype.findIndex &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.fill
                    <pre><code>(function (){
  return typeof Array.prototype.fill &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.keys
                    <pre><code>(function (){
  return typeof Array.prototype.keys &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.values
                    <pre><code>(function (){
  return typeof Array.prototype.values &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype.entries
                    <pre><code>(function (){
  return typeof Array.prototype.entries &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype[Symbol.iterator]
                    <pre><code>(function (){
  return typeof Array.prototype[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array iterator prototype chain
                    <pre><code>(function (){
  // Iterator instance
  var iterator &#x3D; [][Symbol.iterator]();
  // %ArrayIteratorPrototype%
  var proto1 &#x3D; Object.getPrototypeOf(iterator);
  // %IteratorPrototype%
  var proto2 &#x3D; Object.getPrototypeOf(proto1);

  return proto2.hasOwnProperty(Symbol.iterator) &amp;&amp;
    !proto1    .hasOwnProperty(Symbol.iterator) &amp;&amp;
    !iterator  .hasOwnProperty(Symbol.iterator) &amp;&amp;
    iterator[Symbol.iterator]() &#x3D;&#x3D;&#x3D; iterator;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Array.prototype[Symbol.unscopables]
                    <pre><code>(function (){
  var unscopables &#x3D; Array.prototype[Symbol.unscopables];
  if (!unscopables) {
    return false;
  }
  var ns &#x3D; &quot;find,findIndex,fill,copyWithin,entries,keys,values&quot;.split(&quot;,&quot;);
  for (var i &#x3D; 0; i &lt; ns.length; i++) {
    if (Array.prototype[ns[i]] &amp;&amp; !unscopables[ns[i]]) return false;
  }
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Number properties

              <ul>
                <li>
                  SUCCESS - Number.isFinite
                    <pre><code>(function (){
  return typeof Number.isFinite &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.isInteger
                    <pre><code>(function (){
  return typeof Number.isInteger &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.isSafeInteger
                    <pre><code>(function (){
  return typeof Number.isSafeInteger &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.isNaN
                    <pre><code>(function (){
  return typeof Number.isNaN &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.EPSILON
                    <pre><code>(function (){
  return typeof Number.EPSILON &#x3D;&#x3D;&#x3D; &#x27;number&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.MIN_SAFE_INTEGER
                    <pre><code>(function (){
  return typeof Number.MIN_SAFE_INTEGER &#x3D;&#x3D;&#x3D; &#x27;number&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number.MAX_SAFE_INTEGER
                    <pre><code>(function (){
  return typeof Number.MAX_SAFE_INTEGER &#x3D;&#x3D;&#x3D; &#x27;number&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Math methods

              <ul>
                <li>
                  SUCCESS - Math.clz32
                    <pre><code>(function (){
  return typeof Math.clz32 &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.imul
                    <pre><code>(function (){
  return typeof Math.imul &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.sign
                    <pre><code>(function (){
  return typeof Math.sign &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.log10
                    <pre><code>(function (){
  return typeof Math.log10 &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.log2
                    <pre><code>(function (){
  return typeof Math.log2 &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.log1p
                    <pre><code>(function (){
  return typeof Math.log1p &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.expm1
                    <pre><code>(function (){
  return typeof Math.expm1 &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.cosh
                    <pre><code>(function (){
  return typeof Math.cosh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.sinh
                    <pre><code>(function (){
  return typeof Math.sinh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.tanh
                    <pre><code>(function (){
  return typeof Math.tanh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.acosh
                    <pre><code>(function (){
  return typeof Math.acosh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.asinh
                    <pre><code>(function (){
  return typeof Math.asinh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.atanh
                    <pre><code>(function (){
  return typeof Math.atanh &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.trunc
                    <pre><code>(function (){
  return typeof Math.trunc &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.fround
                    <pre><code>(function (){
  return typeof Math.fround &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.cbrt
                    <pre><code>(function (){
  return typeof Math.cbrt &#x3D;&#x3D;&#x3D; &quot;function&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Math.hypot
                    <pre><code>(function (){
  return Math.hypot() &#x3D;&#x3D;&#x3D; 0 &amp;&amp;
    Math.hypot(1) &#x3D;&#x3D;&#x3D; 1 &amp;&amp;
    Math.hypot(9, 12, 20) &#x3D;&#x3D;&#x3D; 25 &amp;&amp;
    Math.hypot(27, 36, 60, 100) &#x3D;&#x3D;&#x3D; 125;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Date.prototype[Symbol.toPrimitive]
              <pre><code>(function (){
  var tp &#x3D; Date.prototype[Symbol.toPrimitive];
  return tp.call(Object(2), &quot;number&quot;) &#x3D;&#x3D;&#x3D; 2
    &amp;&amp; tp.call(Object(2), &quot;string&quot;) &#x3D;&#x3D;&#x3D; &quot;2&quot;
    &amp;&amp; tp.call(Object(2), &quot;default&quot;) &#x3D;&#x3D;&#x3D; &quot;2&quot;;
})()</code></pre>
              <span>Result: TypeError: Cannot read property &#x27;call&#x27; of undefined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Array is subclassable

              <ul>
                <li>
                  SUCCESS - length property (accessing)
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Array {}
  var c &#x3D; new C();
  var len1 &#x3D; c.length;
  c[2] &#x3D; &#x27;foo&#x27;;
  var len2 &#x3D; c.length;
  return len1 &#x3D;&#x3D;&#x3D; 0 &amp;&amp; len2 &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - length property (setting)
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Array {}
  var c &#x3D; new C();
  c[2] &#x3D; &#x27;foo&#x27;;
  c.length &#x3D; 1;
  return c.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; !(2 in c);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - correct prototype chain
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Array {}
  var c &#x3D; new C();
  return c instanceof C &amp;&amp; c instanceof Array &amp;&amp; Object.getPrototypeOf(C) &#x3D;&#x3D;&#x3D; Array;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.isArray support
                    <pre><code>(function (){
  class C extends Array {}
  return Array.isArray(new C());
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.concat
                    <pre><code>(function (){
  class C extends Array {}
  var c &#x3D; new C();
  return c.concat(1) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.filter
                    <pre><code>(function (){
  class C extends Array {}
  var c &#x3D; new C();
  return c.filter(Boolean) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.map
                    <pre><code>(function (){
  class C extends Array {}
  var c &#x3D; new C();
  return c.map(Boolean) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.slice
                    <pre><code>(function (){
  class C extends Array {}
  var c &#x3D; new C();
  c.push(2,4,6);
  return c.slice(1,2) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.splice
                    <pre><code>(function (){
  class C extends Array {}
  var c &#x3D; new C();
  c.push(2,4,6);
  return c.splice(1,2) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from
                    <pre><code>(function (){
  class C extends Array {}
  return C.from({ length: 0 }) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.of
                    <pre><code>(function (){
  class C extends Array {}
  return C.of(0) instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - RegExp is subclassable

              <ul>
                <li>
                  SUCCESS - basic functionality
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class R extends RegExp {}
  var r &#x3D; new R(&quot;baz&quot;,&quot;g&quot;);
  return r.global &amp;&amp; r.source &#x3D;&#x3D;&#x3D; &quot;baz&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - correct prototype chain
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class R extends RegExp {}
  var r &#x3D; new R(&quot;baz&quot;,&quot;g&quot;);
  return r instanceof R &amp;&amp; r instanceof RegExp &amp;&amp; Object.getPrototypeOf(R) &#x3D;&#x3D;&#x3D; RegExp;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.exec
                    <pre><code>(function (){
  class R extends RegExp {}
  var r &#x3D; new R(&quot;baz&quot;,&quot;g&quot;);
  return r.exec(&quot;foobarbaz&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;baz&quot; &amp;&amp; r.lastIndex &#x3D;&#x3D;&#x3D; 9;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.test
                    <pre><code>(function (){
  class R extends RegExp {}
  var r &#x3D; new R(&quot;baz&quot;);
  return r.test(&quot;foobarbaz&quot;);
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Function is subclassable

              <ul>
                <li>
                  SUCCESS - can be called
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Function {}
  var c &#x3D; new C(&quot;return &#x27;foo&#x27;;&quot;);
  return c() &#x3D;&#x3D;&#x3D; &#x27;foo&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - correct prototype chain
                    <pre><code>(function (){
  class C extends Function {}
  var c &#x3D; new C(&quot;return &#x27;foo&#x27;;&quot;);
  return c instanceof C &amp;&amp; c instanceof Function &amp;&amp; Object.getPrototypeOf(C) &#x3D;&#x3D;&#x3D; Function;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - can be used with &quot;new&quot;
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Function {}
  var c &#x3D; new C(&quot;this.bar &#x3D; 2;&quot;);
  c.prototype.baz &#x3D; 3;
  return new c().bar &#x3D;&#x3D;&#x3D; 2 &amp;&amp; new c().baz &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Function.prototype.call
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Function {}
  var c &#x3D; new C(&quot;x&quot;, &quot;return this.bar + x;&quot;);
  return c.call({bar:1}, 2) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Function.prototype.apply
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Function {}
  var c &#x3D; new C(&quot;x&quot;, &quot;return this.bar + x;&quot;);
  return c.apply({bar:1}, [2]) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Function.prototype.bind
                    <pre><code>(function (){
  class C extends Function {}
  var c &#x3D; new C(&quot;x&quot;, &quot;y&quot;, &quot;return this.bar + x + y;&quot;).bind({bar:1}, 2);
  return c(6) &#x3D;&#x3D;&#x3D; 9 &amp;&amp; c instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Promise is subclassable

              <ul>
                <li>
                  FAIL - basic functionality
                    <pre><code>(function (){
  class P extends Promise {}
  var p1 &#x3D; new P(function(resolve, reject) { resolve(&quot;foo&quot;); });
  var p2 &#x3D; new P(function(resolve, reject) { reject(&quot;quux&quot;); });
  var score &#x3D; +(p1 instanceof P);

  function thenFn(result)  { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;foo&quot;);  check(); }
  function catchFn(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;quux&quot;); check(); }
  function shouldNotRun(result)  { score &#x3D; -Infinity;   }

  p1.then(thenFn, shouldNotRun);
  p2.then(shouldNotRun, catchFn);
  p1.catch(shouldNotRun);
  p2.catch(catchFn);

  p1.then(function() {
    // P.prototype.then() should return a new P
    score +&#x3D; p1.then() instanceof P &amp;&amp; p1.then() !&#x3D;&#x3D; p1;
    check();
  });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 5) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: true</span>
                </li>
                <li>
                  SUCCESS - correct prototype chain
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Promise {}
  var c &#x3D; new C(function(resolve, reject) { resolve(&quot;foo&quot;); });
  return c instanceof C &amp;&amp; c instanceof Promise &amp;&amp; Object.getPrototypeOf(C) &#x3D;&#x3D;&#x3D; Promise;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Promise.all
                    <pre><code>(function (){
  class P extends Promise {}
  var fulfills &#x3D; P.all([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,100,&quot;bar&quot;); }),
  ]);
  var rejects &#x3D; P.all([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 100,&quot;qux&quot;); }),
  ]);
  var score &#x3D; +(fulfills instanceof P);
  fulfills.then(function(result) { score +&#x3D; (result + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;qux&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 3) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: true</span>
                </li>
                <li>
                  FAIL - Promise.race
                    <pre><code>(function (){
  class P extends Promise {}
  var fulfills &#x3D; P.race([
    new Promise(function(resolve)   { setTimeout(resolve,200,&quot;foo&quot;); }),
    new Promise(function(_, reject) { setTimeout(reject, 300,&quot;bar&quot;); }),
  ]);
  var rejects &#x3D; P.race([
    new Promise(function(_, reject) { setTimeout(reject, 200,&quot;baz&quot;); }),
    new Promise(function(resolve)   { setTimeout(resolve,300,&quot;qux&quot;); }),
  ]);
  var score &#x3D; +(fulfills instanceof P);
  fulfills.then(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;foo&quot;); check(); });
  rejects.catch(function(result) { score +&#x3D; (result &#x3D;&#x3D;&#x3D; &quot;baz&quot;); check(); });

  function check() {
    if (score &#x3D;&#x3D;&#x3D; 3) asyncTestPassed();
  }
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: true</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - miscellaneous subclassables

              <ul>
                <li>
                  SUCCESS - Boolean is subclassable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Boolean {}
  var c &#x3D; new C(true);
  return c instanceof Boolean
    &amp;&amp; c instanceof C
    &amp;&amp; c &#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Number is subclassable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends Number {}
  var c &#x3D; new C(6);
  return c instanceof Number
    &amp;&amp; c instanceof C
    &amp;&amp; +c &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String is subclassable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  class C extends String {}
  var c &#x3D; new C(&quot;golly&quot;);
  return c instanceof String
    &amp;&amp; c instanceof C
    &amp;&amp; c + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;golly&quot;
    &amp;&amp; c[0] &#x3D;&#x3D;&#x3D; &quot;g&quot;
    &amp;&amp; c.length &#x3D;&#x3D;&#x3D; 5;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Map is subclassable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var key &#x3D; {};
  class M extends Map {}
  var map &#x3D; new M();

  map.set(key, 123);

  return map instanceof M &amp;&amp; map.has(key) &amp;&amp; map.get(key) &#x3D;&#x3D;&#x3D; 123;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Set is subclassable
                    <pre><code>(function (){
  &quot;use strict&quot;;
  var obj &#x3D; {};
  class S extends Set {}
  var set &#x3D; new S();

  set.add(123);
  set.add(123);

  return set instanceof S &amp;&amp; set.has(123);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - prototype of bound functions

              <ul>
                <li>
                  FAIL - basic functions
                    <pre><code>(function (){
  function correctProtoBound(proto) {
    var f &#x3D; function(){};
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(f, proto);
    }
    else {
      f.__proto__ &#x3D; proto;
    }
    var boundF &#x3D; Function.prototype.bind.call(f, null);
    return Object.getPrototypeOf(boundF) &#x3D;&#x3D;&#x3D; proto;
  }
  return correctProtoBound(Function.prototype)
    &amp;&amp; correctProtoBound({})
    &amp;&amp; correctProtoBound(null);
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - generator functions
                    <pre><code>(function (){
  function correctProtoBound(proto) {
    var f &#x3D; function*(){};
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(f, proto);
    }
    else {
      f.__proto__ &#x3D; proto;
    }
    var boundF &#x3D; Function.prototype.bind.call(f, null);
    return Object.getPrototypeOf(boundF) &#x3D;&#x3D;&#x3D; proto;
  }
  return correctProtoBound(Function.prototype)
    &amp;&amp; correctProtoBound({})
    &amp;&amp; correctProtoBound(null);
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - arrow functions
                    <pre><code>(function (){
  function correctProtoBound(proto) {
    var f &#x3D; ()&#x3D;&gt;5;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(f, proto);
    }
    else {
      f.__proto__ &#x3D; proto;
    }
    var boundF &#x3D; Function.prototype.bind.call(f, null);
    return Object.getPrototypeOf(boundF) &#x3D;&#x3D;&#x3D; proto;
  }
  return correctProtoBound(Function.prototype)
    &amp;&amp; correctProtoBound({})
    &amp;&amp; correctProtoBound(null);
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - classes
                    <pre><code>(function (){
  function correctProtoBound(proto) {
    class C {}
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(C, proto);
    }
    else {
      C.__proto__ &#x3D; proto;
    }
    var boundF &#x3D; Function.prototype.bind.call(C, null);
    return Object.getPrototypeOf(boundF) &#x3D;&#x3D;&#x3D; proto;
  }
  return correctProtoBound(Function.prototype)
    &amp;&amp; correctProtoBound({})
    &amp;&amp; correctProtoBound(null);
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - subclasses
                    <pre><code>(function (){
  function correctProtoBound(superclass) {
    class C extends superclass {
      constructor() {
        return Object.create(null);
      }
    }
    var boundF &#x3D; Function.prototype.bind.call(C, null);
    return Object.getPrototypeOf(boundF) &#x3D;&#x3D;&#x3D; Object.getPrototypeOf(C);
  }
  return correctProtoBound(function(){})
    &amp;&amp; correctProtoBound(Array)
    &amp;&amp; correctProtoBound(null);
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;get&#x27; calls

              <ul>
                <li>
                  FAIL - ToPrimitive
                    <pre><code>(function (){
  // ToPrimitive -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({toString:Function()}, { get: function(o, k) { get.push(k); return o[k]; }});
  p + 3;
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;valueOf,toString&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - CreateListFromArrayLike
                    <pre><code>(function (){
  // CreateListFromArrayLike -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({length:2, 0:0, 1:0}, { get: function(o, k) { get.push(k); return o[k]; }});
  Function.prototype.apply({}, p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,0,1&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - instanceof operator
                    <pre><code>(function (){
  // InstanceofOperator -&gt; GetMethod -&gt; GetV -&gt; [[Get]]
  // InstanceofOperator -&gt; OrdinaryHasInstance -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy(Function(), { get: function(o, k) { get.push(k); return o[k]; }});
  ({}) instanceof p;
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.hasInstance &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;prototype&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - HasBinding
                    <pre><code>(function (){
  // HasBinding -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({foo:1}, { get: function(o, k) { get.push(k); return o[k]; }});
  p[Symbol.unscopables] &#x3D; p;
  with(p) {
    typeof foo;
  }
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.unscopables &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - CreateDynamicFunction
                    <pre><code>(function (){
  // CreateDynamicFunction -&gt; GetPrototypeFromConstructor -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy(Function, { get: function(o, k) { get.push(k); return o[k]; }});
  new p;
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;prototype&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - ClassDefinitionEvaluation
                    <pre><code>(function (){
  // ClassDefinitionEvaluation -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy(Function(), { get: function(o, k) { get.push(k); return o[k]; }});
  class C extends p {}
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;prototype&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - IteratorComplete, IteratorValue
                    <pre><code>(function (){
  // IteratorComplete -&gt; Get -&gt; [[Get]]
  // IteratorValue -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var iterable &#x3D; {};
  iterable[Symbol.iterator] &#x3D; function() {
    return {
      next: function() {
        return new Proxy({ value: 2, done: false }, { get: function(o, k) { get.push(k); return o[k]; }});
      }
    };
  }
  var i &#x3D; 0;
  for(var e of iterable) {
    if (++i &gt;&#x3D; 2) break;
  }
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;done,value,done,value&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - ToPropertyDescriptor
                    <pre><code>(function (){
  // ToPropertyDescriptor -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({
      enumerable: true, configurable: true, value: true,
      writable: true, get: Function(), set: Function()
    }, { get: function(o, k) { get.push(k); return o[k]; }});
  try {
    // This will throw, since it will have true for both &quot;get&quot; and &quot;value&quot;,
    // but not before performing a Get on every property.
    Object.defineProperty({}, &quot;foo&quot;, p);
  } catch(e) {
    return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;enumerable,configurable,value,writable,get,set&quot;;
  }
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object.assign
                    <pre><code>(function (){
  // Object.assign -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({foo:1, bar:2}, { get: function(o, k) { get.push(k); return o[k]; }});
  Object.assign({}, p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object.defineProperties
                    <pre><code>(function (){
  // Object.defineProperties -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({foo:{}, bar:{}}, { get: function(o, k) { get.push(k); return o[k]; }});
  Object.defineProperties({}, p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Function.prototype.bind
                    <pre><code>(function (){
  // Function.prototype.bind -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy(Function(), { get: function(o, k) { get.push(k); return o[k]; }});
  Function.prototype.bind.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,name&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Error.prototype.toString
                    <pre><code>(function (){
  // Error.prototype.toString -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({}, { get: function(o, k) { get.push(k); return o[k]; }});
  Error.prototype.toString.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;name,message&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.raw
                    <pre><code>(function (){
  // String.raw -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var raw &#x3D; new Proxy({length: 2, 0: &#x27;&#x27;, 1: &#x27;&#x27;}, { get: function(o, k) { get.push(k); return o[k]; }});
  var p &#x3D; new Proxy({raw: raw}, { get: function(o, k) { get.push(k); return o[k]; }});
  String.raw(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;raw,length,0,1&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp constructor
                    <pre><code>(function (){
  // RegExp -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var re &#x3D; { constructor: null };
  re[Symbol.match] &#x3D; true;
  var p &#x3D; new Proxy(re, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.match &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;constructor,source,flags&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.flags
                    <pre><code>(function (){
  // RegExp.prototype.flags -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({}, { get: function(o, k) { get.push(k); return o[k]; }});
  Object.getOwnPropertyDescriptor(RegExp.prototype, &#x27;flags&#x27;).get.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;global,ignoreCase,multiline,unicode,sticky&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.test
                    <pre><code>(function (){
  // RegExp.prototype.test -&gt; RegExpExec -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({ exec: function() { return null; } }, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype.test.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;exec&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.toString
                    <pre><code>(function (){
  // RegExp.prototype.toString -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({}, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype.toString.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;source,flags&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.match]
                    <pre><code>(function (){
  // RegExp.prototype[Symbol.match] -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({ exec: function() { return null; } }, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype[Symbol.match].call(p);
  p.global &#x3D; true;
  RegExp.prototype[Symbol.match].call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;global,exec,global,unicode,exec&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.replace]
                    <pre><code>(function (){
  // RegExp.prototype[Symbol.replace] -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({ exec: function() { return null; } }, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype[Symbol.replace].call(p);
  p.global &#x3D; true;
  RegExp.prototype[Symbol.replace].call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;global,exec,global,unicode,exec&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.search]
                    <pre><code>(function (){
  // RegExp.prototype[Symbol.search] -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({ exec: function() { return null; } }, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype[Symbol.search].call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;lastIndex,exec&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype[Symbol.split]
                    <pre><code>(function (){
  // RegExp.prototype[Symbol.split] -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var constructor &#x3D; Function();
  constructor[Symbol.species] &#x3D; Object;
  var p &#x3D; new Proxy({ constructor: constructor, flags: &#x27;&#x27;, exec: function() { return null; } }, { get: function(o, k) { get.push(k); return o[k]; }});
  RegExp.prototype[Symbol.split].call(p, &quot;&quot;);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;constructor,flags,exec&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from
                    <pre><code>(function (){
  // Array.from -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({length: 2, 0: &#x27;&#x27;, 1: &#x27;&#x27;}, { get: function(o, k) { get.push(k); return o[k]; }});
  Array.from(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.iterator &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,0,1&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.concat
                    <pre><code>(function (){
  // Array.prototype.concat -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var arr &#x3D; [1];
  arr.constructor &#x3D; undefined;
  var p &#x3D; new Proxy(arr, { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.concat.call(p,p);
  return get[0] &#x3D;&#x3D;&#x3D; &quot;constructor&quot;
    &amp;&amp; get[1] &#x3D;&#x3D;&#x3D; Symbol.isConcatSpreadable
    &amp;&amp; get[2] &#x3D;&#x3D;&#x3D; &quot;length&quot;
    &amp;&amp; get[3] &#x3D;&#x3D;&#x3D; &quot;0&quot;
    &amp;&amp; get[4] &#x3D;&#x3D;&#x3D; get[1] &amp;&amp; get[5] &#x3D;&#x3D;&#x3D; get[2] &amp;&amp; get[6] &#x3D;&#x3D;&#x3D; get[3]
    &amp;&amp; get.length &#x3D;&#x3D;&#x3D; 7;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype iteration methods
                    <pre><code>(function (){
  // Array.prototype methods -&gt; Get -&gt; [[Get]]
  var methods &#x3D; [&#x27;copyWithin&#x27;, &#x27;every&#x27;, &#x27;fill&#x27;, &#x27;filter&#x27;, &#x27;find&#x27;, &#x27;findIndex&#x27;, &#x27;forEach&#x27;,
    &#x27;indexOf&#x27;, &#x27;join&#x27;, &#x27;lastIndexOf&#x27;, &#x27;map&#x27;, &#x27;reduce&#x27;, &#x27;reduceRight&#x27;, &#x27;some&#x27;];
  var get;
  var p &#x3D; new Proxy({length: 2, 0: &#x27;&#x27;, 1: &#x27;&#x27;}, { get: function(o, k) { get.push(k); return o[k]; }});
  for(var i &#x3D; 0; i &lt; methods.length; i+&#x3D;1) {
    get &#x3D; [];
    Array.prototype[methods[i]].call(p, Function());
    if (get + &#x27;&#x27; !&#x3D;&#x3D; (
      methods[i] &#x3D;&#x3D;&#x3D; &#x27;fill&#x27; ? &quot;length&quot; :
      methods[i] &#x3D;&#x3D;&#x3D; &#x27;every&#x27; ? &quot;length,0&quot; :
      methods[i] &#x3D;&#x3D;&#x3D; &#x27;lastIndexOf&#x27; || methods[i] &#x3D;&#x3D;&#x3D; &#x27;reduceRight&#x27; ? &quot;length,1,0&quot; :
      &quot;length,0,1&quot;
    )) {
      return false;
    }
  }
  return true;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.pop
                    <pre><code>(function (){
  // Array.prototype.pop -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy([0,1,2,3], { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.pop.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,3&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.reverse
                    <pre><code>(function (){
  // Array.prototype.reverse -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy([0,,2,,4,,], { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.reverse.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,0,4,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.shift
                    <pre><code>(function (){
  // Array.prototype.shift -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy([0,1,2,3], { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.shift.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,0,1,2,3&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.splice
                    <pre><code>(function (){
  // Array.prototype.splice -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy([0,1,2,3], { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.splice.call(p,1,1);
  Array.prototype.splice.call(p,1,0,1);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,constructor,1,2,3,length,constructor,2,1&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.toString
                    <pre><code>(function (){
  // Array.prototype.toString -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({ join:Function() }, { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.toString.call(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;join&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - JSON.stringify
                    <pre><code>(function (){
  // JSON.stringify -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({}, { get: function(o, k) { get.push(k); return o[k]; }});
  JSON.stringify(p);
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;toJSON&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Promise resolve functions
                    <pre><code>(function (){
  // Promise resolve functions -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({}, { get: function(o, k) { get.push(k); return o[k]; }});
  new Promise(function(resolve){ resolve(p); });
  return get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;then&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.match
                    <pre><code>(function (){
  // String.prototype.match -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var proxied &#x3D; {};
  proxied[Symbol.toPrimitive] &#x3D; Function();
  var p &#x3D; new Proxy(proxied, { get: function(o, k) { get.push(k); return o[k]; }});
  &quot;&quot;.match(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.match &amp;&amp; get[1] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.replace
                    <pre><code>(function (){
  // String.prototype.replace functions -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var proxied &#x3D; {};
  proxied[Symbol.toPrimitive] &#x3D; Function();
  var p &#x3D; new Proxy(proxied, { get: function(o, k) { get.push(k); return o[k]; }});
  &quot;&quot;.replace(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.replace &amp;&amp; get[1] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.search
                    <pre><code>(function (){
  // String.prototype.search functions -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var proxied &#x3D; {};
  proxied[Symbol.toPrimitive] &#x3D; Function();
  var p &#x3D; new Proxy(proxied, { get: function(o, k) { get.push(k); return o[k]; }});
  &quot;&quot;.search(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.search &amp;&amp; get[1] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.split
                    <pre><code>(function (){
  // String.prototype.split functions -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var proxied &#x3D; {};
  proxied[Symbol.toPrimitive] &#x3D; Function();
  var p &#x3D; new Proxy(proxied, { get: function(o, k) { get.push(k); return o[k]; }});
  &quot;&quot;.split(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.split &amp;&amp; get[1] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.length &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Date.prototype.toJSON
                    <pre><code>(function (){
  // Date.prototype.toJSON -&gt; ToPrimitive -&gt; Get -&gt; [[Get]]
  // Date.prototype.toJSON -&gt; Invoke -&gt; GetMethod -&gt; GetV -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({toString:Function(),toISOString:Function()}, { get: function(o, k) { get.push(k); return o[k]; }});
  Date.prototype.toJSON.call(p);
  return get[0] &#x3D;&#x3D;&#x3D; Symbol.toPrimitive &amp;&amp; get.slice(1) + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;valueOf,toString,toISOString&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;set&#x27; calls

              <ul>
                <li>
                  FAIL - Object.assign
                    <pre><code>(function (){
  // Object.assign -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy({}, { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  Object.assign(p, { foo: 1, bar: 2 });
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.from
                    <pre><code>(function (){
  // Array.from -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy({}, { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  Array.from.call(function(){ return p; }, {length:2, 0:1, 1:2});
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.of
                    <pre><code>(function (){
  // Array.from -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy({}, { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  Array.of.call(function(){ return p; }, 1, 2, 3);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.copyWithin
                    <pre><code>(function (){
  // Array.prototype.copyWithin -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([1,2,3,4,5,6], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.copyWithin(0, 3);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,1,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.fill
                    <pre><code>(function (){
  // Array.prototype.fill -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([1,2,3,4,5,6], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.fill(0, 3);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,4,5&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.pop
                    <pre><code>(function (){
  // Array.prototype.pop -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.pop();
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.push
                    <pre><code>(function (){
  // Array.prototype.push -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.push(0,0,0);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,1,2,length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.reverse
                    <pre><code>(function (){
  // Array.prototype.reverse -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([0,0,0,,], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.reverse();
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,1,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.shift
                    <pre><code>(function (){
  // Array.prototype.shift -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([0,0,,0], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.shift();
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,2,length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.splice
                    <pre><code>(function (){
  // Array.prototype.splice -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([1,2,3], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.splice(1,0,0);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,2,1,length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.unshift
                    <pre><code>(function (){
  // Array.prototype.unshift -&gt; Set -&gt; [[Set]]
  var set &#x3D; [];
  var p &#x3D; new Proxy([0,0,,0], { set: function(o, k, v) { set.push(k); o[k] &#x3D; v; return true; }});
  p.unshift(0,1);
  return set + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;5,3,2,0,1,length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;defineProperty&#x27; calls

              <ul>
                <li>
                  FAIL - [[Set]]
                    <pre><code>(function (){
  // [[Set]] -&gt; [[DefineOwnProperty]]
  var def &#x3D; [];
  var p &#x3D; new Proxy({foo:1, bar:2}, { defineProperty: function(o, v, desc) { def.push(v); Object.defineProperty(o, v, desc); return true; }});
  p.foo &#x3D; 2; p.bar &#x3D; 4;
  return def + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SetIntegrityLevel
                    <pre><code>(function (){
  // SetIntegrityLevel -&gt; DefinePropertyOrThrow -&gt; [[DefineOwnProperty]]
  var def &#x3D; [];
  var p &#x3D; new Proxy({foo:1, bar:2}, { defineProperty: function(o, v, desc) { def.push(v); Object.defineProperty(o, v, desc); return true; }});
  Object.freeze(p);
  return def + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;deleteProperty&#x27; calls

              <ul>
                <li>
                  FAIL - Array.prototype.copyWithin
                    <pre><code>(function (){
  // Array.prototype.copyWithin -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,0,0,,,,], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.copyWithin(0,3);
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,1,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.pop
                    <pre><code>(function (){
  // Array.prototype.pop -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,0,0], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.pop();
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.reverse
                    <pre><code>(function (){
  // Array.prototype.reverse -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,,2,,4,,], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.reverse();
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,4,2&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.shift
                    <pre><code>(function (){
  // Array.prototype.shift -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,,0,,0,0], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.shift();
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;0,2,5&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.splice
                    <pre><code>(function (){
  // Array.prototype.splice -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,0,0,0,,0], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.splice(2,2,0);
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;3,5&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.unshift
                    <pre><code>(function (){
  // Array.prototype.unshift -&gt; DeletePropertyOrThrow -&gt; [[Delete]]
  var del &#x3D; [];
  var p &#x3D; new Proxy([0,0,,0,,0], { deleteProperty: function(o, v) { del.push(v); return delete o[v]; }});
  p.unshift(0);
  return del + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;5,3&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;getOwnPropertyDescriptor&#x27; calls

              <ul>
                <li>
                  FAIL - [[Set]]
                    <pre><code>(function (){
  // [[Set]] -&gt; [[GetOwnProperty]]
  var gopd &#x3D; [];
  var p &#x3D; new Proxy({},
    { getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }});
  p.foo &#x3D; 1; p.bar &#x3D; 1;
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object.assign
                    <pre><code>(function (){
  // Object.assign -&gt; [[GetOwnProperty]]
  var gopd &#x3D; [];
  var p &#x3D; new Proxy({foo:1, bar:2},
    { getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }});
  Object.assign({}, p);
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo,bar&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object.prototype.hasOwnProperty
                    <pre><code>(function (){
  // Object.prototype.hasOwnProperty -&gt; HasOwnProperty -&gt; [[GetOwnProperty]]
  var gopd &#x3D; [];
  var p &#x3D; new Proxy({foo:1, bar:2},
    { getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }});
  p.hasOwnProperty(&#x27;garply&#x27;);
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;garply&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Function.prototype.bind
                    <pre><code>(function (){
  // Function.prototype.bind -&gt; HasOwnProperty -&gt; [[GetOwnProperty]]
  var gopd &#x3D; [];
  var p &#x3D; new Proxy(Function(),
    { getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }});
  p.bind();
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy, internal &#x27;ownKeys&#x27; calls

              <ul>
                <li>
                  FAIL - SetIntegrityLevel
                    <pre><code>(function (){
  // SetIntegrityLevel -&gt; [[OwnPropertyKeys]]
  var ownKeysCalled &#x3D; 0;
  var p &#x3D; new Proxy({}, { ownKeys: function(o) { ownKeysCalled++; return Object.keys(o); }});
  Object.freeze(p);
  return ownKeysCalled &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - TestIntegrityLevel
                    <pre><code>(function (){
  // TestIntegrityLevel -&gt; [[OwnPropertyKeys]]
  var ownKeysCalled &#x3D; 0;
  var p &#x3D; new Proxy(Object.preventExtensions({}), { ownKeys: function(o) { ownKeysCalled++; return Object.keys(o); }});
  Object.isFrozen(p);
  return ownKeysCalled &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SerializeJSONObject
                    <pre><code>(function (){
  // SerializeJSONObject -&gt; EnumerableOwnNames -&gt; [[OwnPropertyKeys]]
  var ownKeysCalled &#x3D; 0;
  var p &#x3D; new Proxy({}, { ownKeys: function(o) { ownKeysCalled++; return Object.keys(o); }});
  JSON.stringify({a:p,b:p});
  return ownKeysCalled &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Object static methods accept primitives

              <ul>
                <li>
                  SUCCESS - Object.getPrototypeOf
                    <pre><code>(function (){
  return Object.getPrototypeOf(&#x27;a&#x27;).constructor &#x3D;&#x3D;&#x3D; String;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getOwnPropertyDescriptor
                    <pre><code>(function (){
  return Object.getOwnPropertyDescriptor(&#x27;a&#x27;, &#x27;foo&#x27;) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.getOwnPropertyNames
                    <pre><code>(function (){
  var s &#x3D; Object.getOwnPropertyNames(&#x27;a&#x27;);
  return s.length &#x3D;&#x3D;&#x3D; 2 &amp;&amp;
    ((s[0] &#x3D;&#x3D;&#x3D; &#x27;length&#x27; &amp;&amp; s[1] &#x3D;&#x3D;&#x3D; &#x27;0&#x27;) || (s[0] &#x3D;&#x3D;&#x3D; &#x27;0&#x27; &amp;&amp; s[1] &#x3D;&#x3D;&#x3D; &#x27;length&#x27;));
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.seal
                    <pre><code>(function (){
  return Object.seal(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; &#x27;a&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.freeze
                    <pre><code>(function (){
  return Object.freeze(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; &#x27;a&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.preventExtensions
                    <pre><code>(function (){
  return Object.preventExtensions(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; &#x27;a&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isSealed
                    <pre><code>(function (){
  return Object.isSealed(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isFrozen
                    <pre><code>(function (){
  return Object.isFrozen(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.isExtensible
                    <pre><code>(function (){
  return Object.isExtensible(&#x27;a&#x27;) &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.keys
                    <pre><code>(function (){
  var s &#x3D; Object.keys(&#x27;a&#x27;);
  return s.length &#x3D;&#x3D;&#x3D; 1 &amp;&amp; s[0] &#x3D;&#x3D;&#x3D; &#x27;0&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - own property order

              <ul>
                <li>
                  SUCCESS - Object.keys
                    <pre><code>(function (){
  var obj &#x3D; {
    // Non-negative integer names appear first in value order
    2:    true,
    0:    true,
    1:    true,
    // Other string names appear in source order
    &#x27; &#x27;:  true,
    // Non-negative integers are sorted above other names
    9:    true,
    D:    true,
    B:    true,
    // Negative integers are treated as other names
    &#x27;-1&#x27;: true,
  };
  // Other string names are added in order of creation
  obj.A &#x3D; true;
  // Non-negative integer names, conversely, ignore order of creation
  obj[3] &#x3D; true;
  // Having a total of 20+ properties doesn&#x27;t affect property order
  &quot;EFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&#x27;&#x27;).forEach(function(key){
    obj[key] &#x3D; true;
  });
  // Object.defineProperty doesn&#x27;t affect the above rules
  Object.defineProperty(obj, &#x27;C&#x27;, { value: true, enumerable: true });
  Object.defineProperty(obj, &#x27;4&#x27;, { value: true, enumerable: true });
  // Deleting and reinserting a property doesn&#x27;t preserve its position
  delete obj[2];
  obj[2] &#x3D; true;

  var forInOrder &#x3D; &#x27;&#x27;;
  for(var key in obj)forInOrder +&#x3D; key;

  return Object.keys(obj).join(&#x27;&#x27;) &#x3D;&#x3D;&#x3D; forInOrder;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Object.getOwnPropertyNames
                    <pre><code>(function (){
  var obj &#x3D; {
    2:    true,
    0:    true,
    1:    true,
    &#x27; &#x27;:  true,
    9:    true,
    D:    true,
    B:    true,
    &#x27;-1&#x27;: true
  };
  obj.A &#x3D; true;
  obj[3] &#x3D; true;
  &quot;EFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&#x27;&#x27;).forEach(function(key){
    obj[key] &#x3D; true;
  });
  Object.defineProperty(obj, &#x27;C&#x27;, { value: true, enumerable: true });
  Object.defineProperty(obj, &#x27;4&#x27;, { value: true, enumerable: true });
  delete obj[2];
  obj[2] &#x3D; true;

  return Object.getOwnPropertyNames(obj).join(&#x27;&#x27;) &#x3D;&#x3D;&#x3D; &quot;012349 DB-1AEFGHIJKLMNOPQRSTUVWXYZC&quot;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Object.assign
                    <pre><code>(function (){
  var result &#x3D; &#x27;&#x27;;
  var target &#x3D; {};

  &quot;012349 DBACEFGHIJKLMNOPQRST&quot;.split(&#x27;&#x27;).concat(-1).forEach(function(key){
    Object.defineProperty(target, key, {
      set: function(){
        result +&#x3D; key;
      }
    })
  });

  var obj &#x3D; {2: 2, 0: 0, 1: 1, &#x27; &#x27;: &#x27; &#x27;, 9: 9, D: &#x27;D&#x27;, B: &#x27;B&#x27;, &#x27;-1&#x27;: &#x27;-1&#x27;};
  Object.defineProperty(obj, &#x27;A&#x27;, {value: &#x27;A&#x27;,  enumerable: true});
  Object.defineProperty(obj, &#x27;3&#x27;, {value: &#x27;3&#x27;,  enumerable: true});
  Object.defineProperty(obj, &#x27;C&#x27;, {value: &#x27;C&#x27;,  enumerable: true});
  Object.defineProperty(obj, &#x27;4&#x27;, {value: &#x27;4&#x27;,  enumerable: true});
  delete obj[2];
  obj[2] &#x3D; true;

  &quot;EFGHIJKLMNOPQRST&quot;.split(&#x27;&#x27;).forEach(function(key){
    obj[key] &#x3D; key;
  });

  Object.assign(target, obj);

  return result &#x3D;&#x3D;&#x3D; &quot;012349 DB-1ACEFGHIJKLMNOPQRST&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - JSON.stringify
                    <pre><code>(function (){
  var obj &#x3D; {
    2:    true,
    0:    true,
    1:    true,
    &#x27; &#x27;:  true,
    9:    true,
    D:    true,
    B:    true,
    &#x27;-1&#x27;: true
  };
  obj.A &#x3D; true;
  obj[3] &#x3D; true;
  &quot;EFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&#x27;&#x27;).forEach(function(key){
    obj[key] &#x3D; true;
  });
  Object.defineProperty(obj, &#x27;C&#x27;, { value: true, enumerable: true });
  Object.defineProperty(obj, &#x27;4&#x27;, { value: true, enumerable: true });
  delete obj[2];
  obj[2] &#x3D; true;

  return JSON.stringify(obj) &#x3D;&#x3D;&#x3D;
    &#x27;{&quot;0&quot;:true,&quot;1&quot;:true,&quot;2&quot;:true,&quot;3&quot;:true,&quot;4&quot;:true,&quot;9&quot;:true,&quot; &quot;:true,&quot;D&quot;:true,&quot;B&quot;:true,&quot;-1&quot;:true,&quot;A&quot;:true,&quot;E&quot;:true,&quot;F&quot;:true,&quot;G&quot;:true,&quot;H&quot;:true,&quot;I&quot;:true,&quot;J&quot;:true,&quot;K&quot;:true,&quot;L&quot;:true,&quot;M&quot;:true,&quot;N&quot;:true,&quot;O&quot;:true,&quot;P&quot;:true,&quot;Q&quot;:true,&quot;R&quot;:true,&quot;S&quot;:true,&quot;T&quot;:true,&quot;U&quot;:true,&quot;V&quot;:true,&quot;W&quot;:true,&quot;X&quot;:true,&quot;Y&quot;:true,&quot;Z&quot;:true,&quot;C&quot;:true}&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - JSON.parse
                    <pre><code>(function (){
  var result &#x3D; &#x27;&#x27;;
  JSON.parse(
    &#x27;{&quot;0&quot;:true,&quot;1&quot;:true,&quot;2&quot;:true,&quot;3&quot;:true,&quot;4&quot;:true,&quot;9&quot;:true,&quot; &quot;:true,&quot;D&quot;:true,&quot;B&quot;:true,&quot;-1&quot;:true,&quot;E&quot;:true,&quot;F&quot;:true,&quot;G&quot;:true,&quot;H&quot;:true,&quot;I&quot;:true,&quot;J&quot;:true,&quot;K&quot;:true,&quot;L&quot;:true,&quot;A&quot;:true,&quot;C&quot;:true}&#x27;,
    function reviver(k,v) {
      result +&#x3D; k;
      return v;
    }
  );
  return result &#x3D;&#x3D;&#x3D; &quot;012349 DB-1EFGHIJKLAC&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.ownKeys, string key order
                    <pre><code>(function (){
  var obj &#x3D; {
    2:    true,
    0:    true,
    1:    true,
    &#x27; &#x27;:  true,
    9:    true,
    D:    true,
    B:    true,
    &#x27;-1&#x27;: true
  };
  obj.A &#x3D; true;
  obj[3] &#x3D; true;
  &quot;EFGHIJKLMNOPQRSTUVWXYZ&quot;.split(&#x27;&#x27;).forEach(function(key){
    obj[key] &#x3D; true;
  });
  Object.defineProperty(obj, &#x27;C&#x27;, { value: true, enumerable: true });
  Object.defineProperty(obj, &#x27;4&#x27;, { value: true, enumerable: true });
  delete obj[2];
  obj[2] &#x3D; true;

  return Reflect.ownKeys(obj).join(&#x27;&#x27;) &#x3D;&#x3D;&#x3D; &quot;012349 DB-1AEFGHIJKLMNOPQRSTUVWXYZC&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.ownKeys, symbol key order
                    <pre><code>(function (){
  var sym1 &#x3D; Symbol(), sym2 &#x3D; Symbol(), sym3 &#x3D; Symbol();
  var obj &#x3D; {
    1:    true,
    A:    true,
  };
  obj.B &#x3D; true;
  obj[sym1] &#x3D; true;
  obj[2] &#x3D; true;
  obj[sym2] &#x3D; true;
  Object.defineProperty(obj, &#x27;C&#x27;, { value: true, enumerable: true });
  Object.defineProperty(obj, sym3,{ value: true, enumerable: true });
  Object.defineProperty(obj, &#x27;D&#x27;, { value: true, enumerable: true });

  var result &#x3D; Reflect.ownKeys(obj);
  var l &#x3D; result.length;
  return result[l-3] &#x3D;&#x3D;&#x3D; sym1 &amp;&amp; result[l-2] &#x3D;&#x3D;&#x3D; sym2 &amp;&amp; result[l-1] &#x3D;&#x3D;&#x3D; sym3;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - miscellaneous

              <ul>
                <li>
                  FAIL - no escaped reserved words as identifiers
                    <pre><code>(function (){
  var \u0061;
  try {
    eval(&#x27;var v\\u0061r&#x27;);
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - duplicate property names in strict mode
                    <pre><code>(function (){
  &#x27;use strict&#x27;;
  return this &#x3D;&#x3D;&#x3D; undefined &amp;&amp; ({ a:1, a:1 }).a &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - no semicolon needed after do-while
                    <pre><code>(function (){
  do {} while (false) return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - no assignments allowed in for-in head
                    <pre><code>(function (){
  try {
    eval(&#x27;for (var i &#x3D; 0 in {}) {}&#x27;);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - accessors aren&#x27;t constructors
                    <pre><code>(function (){
  try {
    new (Object.getOwnPropertyDescriptor({get a(){}}, &#x27;a&#x27;)).get;
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - Invalid Date
                    <pre><code>(function (){
  return new Date(NaN) + &quot;&quot; &#x3D;&#x3D;&#x3D; &quot;Invalid Date&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp constructor can alter flags
                    <pre><code>(function (){
  return new RegExp(/./im, &quot;g&quot;).global &#x3D;&#x3D;&#x3D; true;
})()</code></pre>
                    <span>Result: TypeError: Cannot supply flags when constructing one RegExp from another</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - RegExp.prototype.toString generic and uses &quot;flags&quot; property
                    <pre><code>(function (){
  return RegExp.prototype.toString.call({source: &#x27;foo&#x27;, flags: &#x27;bar&#x27;}) &#x3D;&#x3D;&#x3D; &#x27;/foo/bar&#x27;;
})()</code></pre>
                    <span>Result: TypeError: Method RegExp.prototype.toString called on incompatible receiver #&lt;Object&gt;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - built-in prototypes are not instances
                    <pre><code>(function (){
  try {
    RegExp.prototype.exec(); return false;
  } catch(e) {}
  try {
    Date.prototype.valueOf(); return false;
  } catch(e) {}

  if (![Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].every(function (E) {
      return Object.prototype.toString.call(E.prototype) &#x3D;&#x3D;&#x3D; &#x27;[object Object]&#x27;;
  })) {
    return false;
  }

  return true;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - function &#x27;length&#x27; is configurable
                    <pre><code>(function (){
  var fn &#x3D; function(a, b) {};

  var desc &#x3D; Object.getOwnPropertyDescriptor(fn, &quot;length&quot;);
  if (desc.configurable) {
    Object.defineProperty(fn, &quot;length&quot;, { value: 1 });
    return fn.length &#x3D;&#x3D;&#x3D; 1;
  }

  return false;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - non-strict function semantics

              <ul>
                <li>
                  FAIL - hoisted block-level function declaration
                    <pre><code>(function (){
  // Note: only available outside of strict mode.
  if (!this) return false;
  var passed &#x3D; f() &#x3D;&#x3D;&#x3D; 1;
  function f() { return 1; }

  passed &amp;&#x3D; typeof g &#x3D;&#x3D;&#x3D; &#x27;undefined&#x27;;
  { function g() { return 1; } }
  passed &amp;&#x3D; g() &#x3D;&#x3D;&#x3D; 1;

  passed &amp;&#x3D; h() &#x3D;&#x3D;&#x3D; 2;
  { function h() { return 1; } }
  function h() { return 2; }
  passed &amp;&#x3D; h() &#x3D;&#x3D;&#x3D; 1;

  return passed;
})()</code></pre>
                    <span>Result: 0</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - labeled function statements
                    <pre><code>(function (){
  // Note: only available outside of strict mode.
  if (!this) return false;

  label: function foo() { return 2; }
  return foo() &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - function statements in if-statement clauses
                    <pre><code>(function (){
  // Note: only available outside of strict mode.
  if (!this) return false;

  if(true) function foo() { return 2; }
  if(false) {} else function bar() { return 3; }
  if(true) function baz() { return 4; } else {}
  if(false) function qux() { return 5; } else function qux() { return 6; }
  return foo() &#x3D;&#x3D;&#x3D; 2 &amp;&amp; bar() &#x3D;&#x3D;&#x3D; 3 &amp;&amp; baz() &#x3D;&#x3D;&#x3D; 4 &amp;&amp; qux() &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - __proto__ in object literals

              <ul>
                <li>
                  SUCCESS - basic support
                    <pre><code>(function (){
  return { __proto__ : [] } instanceof Array
    &amp;&amp; !({ __proto__ : null } instanceof Object);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - multiple __proto__ is an error
                    <pre><code>(function (){
  try {
    eval(&quot;({ __proto__ : [], __proto__: {} })&quot;);
  }
  catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - not a computed property
                    <pre><code>(function (){
  if (!({ __proto__ : [] } instanceof Array)) {
    return false;
  }
  var a &#x3D; &quot;__proto__&quot;;
  return !({ [a] : [] } instanceof Array);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - not a shorthand property
                    <pre><code>(function (){
  if (!({ __proto__ : [] } instanceof Array)) {
    return false;
  }
  var __proto__ &#x3D; [];
  return !({ __proto__ } instanceof Array);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - not a shorthand method
                    <pre><code>(function (){
  if (!({ __proto__ : [] } instanceof Array)) {
    return false;
  }
  return !({ __proto__(){} } instanceof Function);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Object.prototype.__proto__

              <ul>
                <li>
                  SUCCESS - get prototype
                    <pre><code>(function (){
  var A &#x3D; function(){};
  return (new A()).__proto__ &#x3D;&#x3D;&#x3D; A.prototype;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - set prototype
                    <pre><code>(function (){
  var o &#x3D; {};
  o.__proto__ &#x3D; Array.prototype;
  return o instanceof Array;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - absent from Object.create(null)
                    <pre><code>(function (){
  var o &#x3D; Object.create(null), p &#x3D; {};
  o.__proto__ &#x3D; p;
  return Object.getPrototypeOf(o) !&#x3D;&#x3D; p;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - present in hasOwnProperty()
                    <pre><code>(function (){
  return Object.prototype.hasOwnProperty(&#x27;__proto__&#x27;);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - correct property descriptor
                    <pre><code>(function (){
  var desc &#x3D; Object.getOwnPropertyDescriptor(Object.prototype,&quot;__proto__&quot;);
  var A &#x3D; function(){};

  return (desc
    &amp;&amp; &quot;get&quot; in desc
    &amp;&amp; &quot;set&quot; in desc
    &amp;&amp; desc.configurable
    &amp;&amp; !desc.enumerable);
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - present in Object.getOwnPropertyNames()
                    <pre><code>(function (){
  return Object.getOwnPropertyNames(Object.prototype).indexOf(&#x27;__proto__&#x27;) &gt; -1;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - String.prototype HTML methods

              <ul>
                <li>
                  FAIL - existence
                    <pre><code>(function (){
  var i, names &#x3D; [&quot;anchor&quot;, &quot;big&quot;, &quot;bold&quot;, &quot;fixed&quot;, &quot;fontcolor&quot;, &quot;fontsize&quot;,
    &quot;italics&quot;, &quot;link&quot;, &quot;small&quot;, &quot;strike&quot;, &quot;sub&quot;, &quot;sup&quot;];
  for (i &#x3D; 0; i &lt; names.length; i++) {
    if (typeof String.prototype[names[i]] !&#x3D;&#x3D; &#x27;function&#x27;) {
      return false;
    }
  }
  return true;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - tags&#x27; names are lowercase
                    <pre><code>(function (){
  var i, names &#x3D; [&quot;anchor&quot;, &quot;big&quot;, &quot;bold&quot;, &quot;fixed&quot;, &quot;fontcolor&quot;, &quot;fontsize&quot;,
    &quot;italics&quot;, &quot;link&quot;, &quot;small&quot;, &quot;strike&quot;, &quot;sub&quot;, &quot;sup&quot;];
  for (i &#x3D; 0; i &lt; names.length; i++) {
    if (&quot;&quot;[names[i]]().toLowerCase() !&#x3D;&#x3D; &quot;&quot;[names[i]]()) {
      return false;
    }
  }
  return true;
})()</code></pre>
                    <span>Result: TypeError: &quot;&quot;[names[i]] is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - quotes in arguments are escaped
                    <pre><code>(function (){
  var i, names &#x3D; [&quot;anchor&quot;, &quot;fontcolor&quot;, &quot;fontsize&quot;, &quot;link&quot;];
  for (i &#x3D; 0; i &lt; names.length; i++) {
    if (&quot;&quot;[names[i]](&#x27;&quot;&#x27;) !&#x3D;&#x3D; &quot;&quot;[names[i]](&#x27;&amp;&#x27; + &#x27;quot;&#x27;)) {
      return false;
    }
  }
  return true;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - RegExp.prototype.compile
              <pre><code>(function (){
  return typeof RegExp.prototype.compile &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
          <li>
            SUCCESS - RegExp syntax extensions

              <ul>
                <li>
                  SUCCESS - hyphens in character sets
                    <pre><code>(function (){
  return /[\w-_]/.exec(&quot;-&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;-&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - invalid character escapes
                    <pre><code>(function (){
  return /\z/.exec(&quot;\\z&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;z&quot;
    &amp;&amp; /[\z]/.exec(&quot;[\\z]&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;z&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - invalid control-character escapes
                    <pre><code>(function (){
  return /\c2/.exec(&quot;\\c2&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;\\c2&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - invalid Unicode escapes
                    <pre><code>(function (){
  return /\u1/.exec(&quot;u1&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;u1&quot;
    &amp;&amp; /[\u1]/.exec(&quot;u&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;u&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - invalid hexadecimal escapes
                    <pre><code>(function (){
  return /\x1/.exec(&quot;x1&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;x1&quot;
    &amp;&amp; /[\x1]/.exec(&quot;x&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;x&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - incomplete patterns and quantifiers
                    <pre><code>(function (){
  return /x{1/.exec(&quot;x{1&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;x{1&quot;
    &amp;&amp; /x]1/.exec(&quot;x]1&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;x]1&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - octal escape sequences
                    <pre><code>(function (){
  return /\041/.exec(&quot;!&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;!&quot;
    &amp;&amp; /[\041]/.exec(&quot;!&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;!&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - invalid backreferences become octal escapes
                    <pre><code>(function (){
  return /\41/.exec(&quot;!&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;!&quot;
    &amp;&amp; /[\41]/.exec(&quot;!&quot;)[0] &#x3D;&#x3D;&#x3D; &quot;!&quot;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - HTML-style comments
              <pre><code>(function (){
  --&gt; A comment
  &lt;!-- Another comment
  var a &#x3D; 3; &lt;!-- Another comment
  return a &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
      </ul>

      <h2>esnext Features</h2>
      <ul>
          <li>
            FAIL - exponentiation (**) operator

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  return 2 ** 3 &#x3D;&#x3D;&#x3D; 8 &amp;&amp; -(5 ** 2) &#x3D;&#x3D;&#x3D; -25 &amp;&amp; (-5) ** 2 &#x3D;&#x3D;&#x3D; 25;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token *</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - assignment
                    <pre><code>(function (){
  var a &#x3D; 2; a **&#x3D; 3; return a &#x3D;&#x3D;&#x3D; 8;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token *&#x3D;</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - early syntax error for unary negation without parens
                    <pre><code>(function (){
  if (2 ** 3 !&#x3D;&#x3D; 8) { return false; }
  try {
    Function(&quot;-5 ** 2&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token *</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Array.prototype.includes

              <ul>
                <li>
                  FAIL - Array.prototype.includes
                    <pre><code>(function (){
  return [1, 2, 3].includes(1)
    &amp;&amp; ![1, 2, 3].includes(4)
    &amp;&amp; ![1, 2, 3].includes(1, 1)
    &amp;&amp; [NaN].includes(NaN)
    &amp;&amp; Array(1).includes();
})()</code></pre>
                    <span>Result: TypeError: [1,2,3].includes is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Array.prototype.includes is generic
                    <pre><code>(function (){
  var passed &#x3D; 0;
  return [].includes.call({
    get &quot;0&quot;() {
      passed &#x3D; NaN;
      return &#x27;foo&#x27;;
    },
    get &quot;11&quot;() {
      passed +&#x3D; 1;
      return 0;
    },
    get &quot;19&quot;() {
      passed +&#x3D; 1;
      return &#x27;foo&#x27;;
    },
    get &quot;21&quot;() {
      passed &#x3D; NaN;
      return &#x27;foo&#x27;;
    },
    get length() {
      passed +&#x3D; 1;
      return 24;
    }
  }, &#x27;foo&#x27;, 6) &#x3D;&#x3D;&#x3D; true &amp;&amp; passed &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: TypeError: Cannot read property &#x27;call&#x27; of undefined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - %TypedArray%.prototype.includes
                    <pre><code>(function (){
  return [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
      Int32Array, Uint32Array, Float32Array, Float64Array].every(function(TypedArray){
    return new TypedArray([1, 2, 3]).includes(1)
      &amp;&amp; !new TypedArray([1, 2, 3]).includes(4)
      &amp;&amp; !new TypedArray([1, 2, 3]).includes(1, 1);
  });
})()</code></pre>
                    <span>Result: TypeError: (intermediate value).includes is not a function</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - generator functions can&#x27;t be used with &quot;new&quot;
              <pre><code>(function (){
  function * generator() {
    yield 3;
  }
  try {
    new generator();
  } catch(e) {
    return true;
  }
})()</code></pre>
              <span>Result: </span>
              <span>Async: false</span>

          </li>
          <li>
            SUCCESS - generator throw() caught by inner generator
              <pre><code>(function (){
  function * generator() {
    yield * (function * () {
      try {
        yield &#x27;foo&#x27;;
      }
      catch(e) {
        return;
      }
    }());
    yield &#x27;bar&#x27;;
  }
  var iter &#x3D; generator();
  iter.next();
  return iter[&#x27;throw&#x27;]().value &#x3D;&#x3D;&#x3D; &#x27;bar&#x27;;
})()</code></pre>
              <span>Result: true</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - strict fn w/ non-strict non-simple params is error
              <pre><code>(function (){
  function foo(...a){}
  try {
    Function(&quot;function bar(...a){&#x27;use strict&#x27;;}&quot;)();
  } catch(e) {
    return true;
  }
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token ...</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - nested rest destructuring, declarations
              <pre><code>(function (){
  var [x, ...[y, ...z]] &#x3D; [1,2,3,4];
  return x &#x3D;&#x3D;&#x3D; 1 &amp;&amp; y &#x3D;&#x3D;&#x3D; 2 &amp;&amp; z + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &#x27;3,4&#x27;;
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token [</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - nested rest destructuring, parameters
              <pre><code>(function (){
  return function([x, ...[y, ...z]]) {
    return x &#x3D;&#x3D;&#x3D; 1 &amp;&amp; y &#x3D;&#x3D;&#x3D; 2 &amp;&amp; z + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &#x27;3,4&#x27;;
  }([1,2,3,4]);
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token [</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Proxy, &quot;enumerate&quot; handler removed
              <pre><code>(function (){
  var passed &#x3D; true;
  var proxy &#x3D; new Proxy({}, {
    enumerate: function() {
      passed &#x3D; false;
    }
  });
  for(var key in proxy); // Should not throw, nor execute the &#x27;enumerate&#x27; method.
  return passed;
})()</code></pre>
              <span>Result: ReferenceError: Proxy is not defined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Proxy internal calls, Array.prototype.includes
              <pre><code>(function (){
  // Array.prototype.includes -&gt; Get -&gt; [[Get]]
  var get &#x3D; [];
  var p &#x3D; new Proxy({length: 3, 0: &#x27;&#x27;, 1: &#x27;&#x27;, 2: &#x27;&#x27;, 3: &#x27;&#x27;}, { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.includes.call(p, {});
  if (get + &#x27;&#x27; !&#x3D;&#x3D; &quot;length,0,1,2&quot;) return;

  get &#x3D; [];
  p &#x3D; new Proxy({length: 4, 0: NaN, 1: &#x27;&#x27;, 2: NaN, 3: &#x27;&#x27;}, { get: function(o, k) { get.push(k); return o[k]; }});
  Array.prototype.includes.call(p, NaN, 1);
  return (get + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;length,1,2&quot;);
})()</code></pre>
              <span>Result: ReferenceError: Proxy is not defined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - class extends null

              <ul>
                <li>
                  FAIL - proper default constructor
                    <pre><code>(function (){
  class C extends null {}
  return new C instanceof C;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - proper &quot;this&quot; binding
                    <pre><code>(function (){
  var passed &#x3D; false;
  new class C extends null {
    constructor() {
      passed &#x3D; (this instanceof C &amp;&amp; !(this instanceof Object));
      return this;
    }
  };
  return passed;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Object.prototype getter/setter methods

              <ul>
                <li>
                  SUCCESS - __defineGetter__
                    <pre><code>(function (){
  var obj &#x3D; {};
  function bar() { return &quot;bar&quot;; }
  Object.prototype.__defineGetter__.call(obj, &quot;foo&quot;, bar);
  var prop &#x3D; Object.getOwnPropertyDescriptor(obj, &quot;foo&quot;);
  return prop.get &#x3D;&#x3D;&#x3D; bar &amp;&amp; !prop.writable &amp;&amp; prop.configurable
    &amp;&amp; prop.enumerable;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __defineGetter__, symbols
                    <pre><code>(function (){
  var obj &#x3D; {};
  var sym &#x3D; Symbol();
  function bar() { return &quot;bar&quot;; }
  Object.prototype.__defineGetter__.call(obj, sym, bar);
  var prop &#x3D; Object.getOwnPropertyDescriptor(obj, sym);
  return prop.get &#x3D;&#x3D;&#x3D; bar &amp;&amp; !prop.writable &amp;&amp; prop.configurable
    &amp;&amp; prop.enumerable;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __defineGetter__, ToObject(this)
                    <pre><code>(function (){
  var key &#x3D; &#x27;__accessors_test__&#x27;;
  __defineGetter__.call(1, key, function(){});
  try {
    __defineGetter__.call(null, key, function(){});
  } catch(e){
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __defineSetter__
                    <pre><code>(function (){
  var obj &#x3D; {};
  function bar() {}
  Object.prototype.__defineSetter__.call(obj, &quot;foo&quot;, bar);
  var prop &#x3D; Object.getOwnPropertyDescriptor(obj, &quot;foo&quot;);
  return prop.set &#x3D;&#x3D;&#x3D; bar &amp;&amp; !prop.writable &amp;&amp; prop.configurable
    &amp;&amp; prop.enumerable;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __defineSetter__, symbols
                    <pre><code>(function (){
  var obj &#x3D; {};
  var sym &#x3D; Symbol();
  function bar(baz) {}
  Object.prototype.__defineSetter__.call(obj, sym, bar);
  var prop &#x3D; Object.getOwnPropertyDescriptor(obj, sym);
  return prop.set &#x3D;&#x3D;&#x3D; bar &amp;&amp; !prop.writable &amp;&amp; prop.configurable
    &amp;&amp; prop.enumerable;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __defineSetter__, ToObject(this)
                    <pre><code>(function (){
  var key &#x3D; &#x27;__accessors_test__&#x27;;
  __defineSetter__.call(1, key, function(){});
  try {
    __defineSetter__.call(null, key, function(){});
  } catch(e){
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupGetter__
                    <pre><code>(function (){
  var obj &#x3D; {
    get foo() { return &quot;bar&quot;},
    qux: 1
  };
  var foo &#x3D; Object.prototype.__lookupGetter__.call(obj, &quot;foo&quot;);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, &quot;qux&quot;) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, &quot;baz&quot;) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupGetter__, prototype chain
                    <pre><code>(function (){
  var obj &#x3D; {
    get foo() { return &quot;bar&quot;},
    qux: 1
  };
  var foo &#x3D; Object.prototype.__lookupGetter__.call(Object.create(obj), &quot;foo&quot;);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, &quot;qux&quot;) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, &quot;baz&quot;) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupGetter__, symbols
                    <pre><code>(function (){
  var sym &#x3D; Symbol();
  var sym2 &#x3D; Symbol();
  var obj &#x3D; {};
  Object.defineProperty(obj, sym, { get: function() { return &quot;bar&quot;; }});
  Object.defineProperty(obj, sym2, { value: 1 });
  var foo &#x3D; Object.prototype.__lookupGetter__.call(obj, sym);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, sym2) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupGetter__.call(obj, Symbol()) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __lookupGetter__, ToObject(this)
                    <pre><code>(function (){
  __lookupGetter__.call(1, &#x27;key&#x27;);
  try {
    __lookupGetter__.call(null, &#x27;key&#x27;);
  } catch(e){
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupSetter__
                    <pre><code>(function (){
  var obj &#x3D; {
    set foo(baz) { return &quot;bar&quot;; },
    qux: 1
  };
  var foo &#x3D; Object.prototype.__lookupSetter__.call(obj, &quot;foo&quot;);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, &quot;qux&quot;) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, &quot;baz&quot;) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupSetter__, prototype chain
                    <pre><code>(function (){
  var obj &#x3D; {
    set foo(baz) { return &quot;bar&quot;; },
    qux: 1
  };
  var foo &#x3D; Object.prototype.__lookupSetter__.call(Object.create(obj), &quot;foo&quot;);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, &quot;qux&quot;) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, &quot;baz&quot;) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - __lookupSetter__, symbols
                    <pre><code>(function (){
  var sym &#x3D; Symbol();
  var sym2 &#x3D; Symbol();
  var obj &#x3D; {};
  Object.defineProperty(obj, sym, { set: function(baz) { return &quot;bar&quot;; }});
  Object.defineProperty(obj, sym2, { value: 1 });
  var foo &#x3D; Object.prototype.__lookupSetter__.call(obj, sym);
  return foo() &#x3D;&#x3D;&#x3D; &quot;bar&quot;
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, sym2) &#x3D;&#x3D;&#x3D; undefined
    &amp;&amp; Object.prototype.__lookupSetter__.call(obj, Symbol()) &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __lookupSetter__, ToObject(this)
                    <pre><code>(function (){
  __lookupSetter__.call(1, &#x27;key&#x27;);
  try {
    __lookupSetter__.call(null, &#x27;key&#x27;);
  } catch(e){
    return true;
  }
})()</code></pre>
                    <span>Result: </span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Proxy internal calls, getter/setter methods

              <ul>
                <li>
                  FAIL - __defineGetter__
                    <pre><code>(function (){
  // Object.prototype.__defineGetter__ -&gt; DefinePropertyOrThrow -&gt; [[DefineOwnProperty]]
  var def &#x3D; [];
  var p &#x3D; new Proxy({}, { defineProperty: function(o, v, desc) { def.push(v); Object.defineProperty(o, v, desc); return true; }});
  Object.prototype.__defineGetter__.call(p, &quot;foo&quot;, Object);
  return def + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __defineSetter__
                    <pre><code>(function (){
  // Object.prototype.__defineSetter__ -&gt; DefinePropertyOrThrow -&gt; [[DefineOwnProperty]]
  var def &#x3D; [];
  var p &#x3D; new Proxy({}, { defineProperty: function(o, v, desc) { def.push(v); Object.defineProperty(o, v, desc); return true; }});
  Object.prototype.__defineSetter__.call(p, &quot;foo&quot;, Object);
  return def + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __lookupGetter__
                    <pre><code>(function (){
  // Object.prototype.__lookupGetter__ -&gt; [[GetOwnProperty]]
  // Object.prototype.__lookupGetter__ -&gt; [[GetPrototypeOf]]
  var gopd &#x3D; [];
  var gpo &#x3D; false;
  var p &#x3D; new Proxy({}, {
    getPrototypeOf: function(o) { gpo &#x3D; true; return Object.getPrototypeOf(o); },
    getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }
  });
  Object.prototype.__lookupGetter__.call(p, &quot;foo&quot;);
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; gpo;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - __lookupSetter__
                    <pre><code>(function (){
  // Object.prototype.__lookupSetter__ -&gt; [[GetOwnProperty]]
  // Object.prototype.__lookupSetter__ -&gt; [[GetPrototypeOf]]
  var gopd &#x3D; [];
  var gpo &#x3D; false;
  var p &#x3D; new Proxy({}, {
    getPrototypeOf: function(o) { gpo &#x3D; true; return Object.getPrototypeOf(o); },
    getOwnPropertyDescriptor: function(o, v) { gopd.push(v); return Object.getOwnPropertyDescriptor(o, v); }
  });
  Object.prototype.__lookupSetter__.call(p, &quot;foo&quot;);
  return gopd + &#x27;&#x27; &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; gpo;
})()</code></pre>
                    <span>Result: ReferenceError: Proxy is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Object.values
              <pre><code>(function (){
  var obj &#x3D; Object.create({ a: &quot;qux&quot;, d: &quot;qux&quot; });
  obj.a &#x3D; &quot;foo&quot;; obj.b &#x3D; &quot;bar&quot;; obj.c &#x3D; &quot;baz&quot;;
  var v &#x3D; Object.values(obj);
  return Array.isArray(v) &amp;&amp; String(v) &#x3D;&#x3D;&#x3D; &quot;foo,bar,baz&quot;;
})()</code></pre>
              <span>Result: TypeError: Object.values is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Object.entries
              <pre><code>(function (){
  var obj &#x3D; Object.create({ a: &quot;qux&quot;, d: &quot;qux&quot; });
  obj.a &#x3D; &quot;foo&quot;; obj.b &#x3D; &quot;bar&quot;; obj.c &#x3D; &quot;baz&quot;;
  var e &#x3D; Object.entries(obj);
  return Array.isArray(e)
    &amp;&amp; e.length &#x3D;&#x3D;&#x3D; 3
    &amp;&amp; String(e[0]) &#x3D;&#x3D;&#x3D; &quot;a,foo&quot;
    &amp;&amp; String(e[1]) &#x3D;&#x3D;&#x3D; &quot;b,bar&quot;
    &amp;&amp; String(e[2]) &#x3D;&#x3D;&#x3D; &quot;c,baz&quot;;
})()</code></pre>
              <span>Result: TypeError: Object.entries is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - trailing commas in function syntax

              <ul>
                <li>
                  FAIL - in parameter lists
                    <pre><code>(function (){
  return typeof function f( a, b, ){} &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token )</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - in argument lists
                    <pre><code>(function (){
  return Math.min(1,2,3,) &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token )</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - async functions

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  return (async function(){
    return 42;
  })() instanceof Promise
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - await support
                    <pre><code>(function (){
  return (async function(){
    return 10 + await Promise.resolve(10);
  })() instanceof Promise
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - arrow async functions
                    <pre><code>(function (){
  return (async () &#x3D;&gt; 42 + await Promise.resolve(42))() instanceof Promise
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token (</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Object.getOwnPropertyDescriptors
              <pre><code>(function (){
  var object &#x3D; {a: 1};
  var B &#x3D; typeof Symbol &#x3D;&#x3D;&#x3D; &#x27;function&#x27; ? Symbol(&#x27;b&#x27;) : &#x27;b&#x27;;
  object[B] &#x3D; 2;
  var O &#x3D; Object.defineProperty(object, &#x27;c&#x27;, {value: 3});
  var D &#x3D; Object.getOwnPropertyDescriptors(O);

  return D.a.value &#x3D;&#x3D;&#x3D; 1 &amp;&amp; D.a.enumerable &#x3D;&#x3D;&#x3D; true &amp;&amp; D.a.configurable &#x3D;&#x3D;&#x3D; true &amp;&amp; D.a.writable &#x3D;&#x3D;&#x3D; true
    &amp;&amp; D[B].value &#x3D;&#x3D;&#x3D; 2 &amp;&amp; D[B].enumerable &#x3D;&#x3D;&#x3D; true &amp;&amp; D[B].configurable &#x3D;&#x3D;&#x3D; true &amp;&amp; D[B].writable &#x3D;&#x3D;&#x3D; true
    &amp;&amp; D.c.value &#x3D;&#x3D;&#x3D; 3 &amp;&amp; D.c.enumerable &#x3D;&#x3D;&#x3D; false &amp;&amp; D.c.configurable &#x3D;&#x3D;&#x3D; false &amp;&amp; D.c.writable &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
              <span>Result: TypeError: Object.getOwnPropertyDescriptors is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - SIMD (Single Instruction, Multiple Data)

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  return typeof SIMD !&#x3D;&#x3D; &#x27;undefined&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Float32x4
                    <pre><code>(function (){
  return typeof SIMD.Float32x4 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Int32x4
                    <pre><code>(function (){
  return typeof SIMD.Int32x4 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Int16x8
                    <pre><code>(function (){
  return typeof SIMD.Int16x8 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Int8x16
                    <pre><code>(function (){
  return typeof SIMD.Int8x16 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Uint32x4
                    <pre><code>(function (){
  return typeof SIMD.Uint32x4 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Uint16x8
                    <pre><code>(function (){
  return typeof SIMD.Uint16x8 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Uint8x16
                    <pre><code>(function (){
  return typeof SIMD.Uint8x16 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Bool32x4
                    <pre><code>(function (){
  return typeof SIMD.Bool32x4 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Bool16x8
                    <pre><code>(function (){
  return typeof SIMD.Bool16x8 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Bool8x16
                    <pre><code>(function (){
  return typeof SIMD.Bool8x16 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.abs
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.abs &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.add
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.add &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%integerType%.addSaturate
                    <pre><code>(function (){
  return typeof SIMD.Int16x8.addSaturate &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.and
                    <pre><code>(function (){
  return typeof SIMD.Bool16x8.and &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.anyTrue
                    <pre><code>(function (){
  return typeof SIMD.Bool32x4.anyTrue &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.allTrue
                    <pre><code>(function (){
  return typeof SIMD.Bool32x4.allTrue &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.check
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.check &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.equal
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.equal &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.extractLane
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.extractLane &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.greaterThan
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.greaterThan &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.greaterThanOrEqual
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.greaterThanOrEqual &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.lessThan
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.lessThan &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.lessThanOrEqual
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.lessThanOrEqual &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.mul
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.mul &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.div
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.div &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.load
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.load &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.load1
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.load1 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.load2
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.load2 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.load3
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.load3 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.max
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.max &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.maxNum
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.maxNum &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.min
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.min &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.minNum
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.minNum &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.neg
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.neg &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.not
                    <pre><code>(function (){
  return typeof SIMD.Bool16x8.not &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.notEqual
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.notEqual &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.or
                    <pre><code>(function (){
  return typeof SIMD.Bool16x8.or &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.reciprocalApproximation
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.reciprocalApproximation &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.reciprocalSqrtApproximation
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.reciprocalSqrtApproximation &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.replaceLane
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.replaceLane &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.select
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.select &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%integerType%.shiftLeftByScalar
                    <pre><code>(function (){
  return typeof SIMD.Int32x4.shiftLeftByScalar &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%integerType%.shiftRightByScalar
                    <pre><code>(function (){
  return typeof SIMD.Int32x4.shiftRightByScalar &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.shuffle
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.shuffle &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.splat
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.splat &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.sqrt
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.sqrt &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.store
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.store &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.store1
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.store1 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.store2
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.store2 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.store3
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.store3 &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.sub
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.sub &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%integerType%.subSaturate
                    <pre><code>(function (){
  return typeof SIMD.Int16x8.subSaturate &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.swizzle
                    <pre><code>(function (){
  return typeof SIMD.Float32x4.swizzle &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%booleanType%.xor
                    <pre><code>(function (){
  return typeof SIMD.Bool16x8.xor &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.fromTIMDBits
                    <pre><code>(function (){
  return &#x27;Float32x4,Int32x4,Int8x16,Uint32x4,Uint16x8,Uint8x16&#x27;.split(&#x27;,&#x27;).every(function(type){
    return typeof SIMD.Int16x8[&#x27;from&#x27; + type + &#x27;Bits&#x27;] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
  });
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SIMD.%type%.fromTIMD
                    <pre><code>(function (){
  return &#x27;Float32x4,Uint32x4&#x27;.split(&#x27;,&#x27;).every(function(type){
    return typeof SIMD.Int32x4[&#x27;from&#x27; + type] &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
  });
})()</code></pre>
                    <span>Result: ReferenceError: SIMD is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - String padding

              <ul>
                <li>
                  FAIL - String.prototype.padStart
                    <pre><code>(function (){
  return &#x27;hello&#x27;.padStart(10) &#x3D;&#x3D;&#x3D; &#x27;     hello&#x27;
    &amp;&amp; &#x27;hello&#x27;.padStart(10, &#x27;1234&#x27;) &#x3D;&#x3D;&#x3D; &#x27;12341hello&#x27;
    &amp;&amp; &#x27;hello&#x27;.padStart() &#x3D;&#x3D;&#x3D; &#x27;hello&#x27;
    &amp;&amp; &#x27;hello&#x27;.padStart(6, &#x27;123&#x27;) &#x3D;&#x3D;&#x3D; &#x27;1hello&#x27;;
})()</code></pre>
                    <span>Result: TypeError: &quot;hello&quot;.padStart is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.padEnd
                    <pre><code>(function (){
  return &#x27;hello&#x27;.padEnd(10) &#x3D;&#x3D;&#x3D; &#x27;hello     &#x27;
    &amp;&amp; &#x27;hello&#x27;.padEnd(10, &#x27;1234&#x27;) &#x3D;&#x3D;&#x3D; &#x27;hello12341&#x27;
    &amp;&amp; &#x27;hello&#x27;.padEnd() &#x3D;&#x3D;&#x3D; &#x27;hello&#x27;
    &amp;&amp; &#x27;hello&#x27;.padEnd(6, &#x27;123&#x27;) &#x3D;&#x3D;&#x3D; &#x27;hello1&#x27;;
})()</code></pre>
                    <span>Result: TypeError: &quot;hello&quot;.padEnd is not a function</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - function.sent
              <pre><code>(function (){
  var result;
  function* generator() {
    result &#x3D; function.sent;
  }
  var iter &#x3D; generator();
  iter.next(&#x27;tromple&#x27;);
  return result &#x3D;&#x3D;&#x3D; &#x27;tromple&#x27;;
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token .</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - object rest properties
              <pre><code>(function (){
  var {a, ...rest} &#x3D; {a: 1, b: 2, c: 3};
  return a &#x3D;&#x3D;&#x3D; 1 &amp;&amp; rest.a &#x3D;&#x3D;&#x3D; undefined &amp;&amp; rest.b &#x3D;&#x3D;&#x3D; 2 &amp;&amp; rest.c &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token ...</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - object spread properties
              <pre><code>(function (){
  var spread &#x3D; {b: 2, c: 3};
  var O &#x3D; {a: 1, ...spread};
  return O.a + O.b + O.c &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token ...</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - System.global
              <pre><code>(function (){
  Function(&#x27;return this&#x27;)().__system_global_test__ &#x3D; 42;
  return System.global.__system_global_test__ &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
              <span>Result: ReferenceError: System is not defined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - shared memory and atomics

              <ul>
                <li>
                  FAIL - SharedArrayBuffer
                    <pre><code>(function (){
  return typeof SharedArrayBuffer &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SharedArrayBuffer.isView
                    <pre><code>(function (){
  return typeof SharedArrayBuffer.isView &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SharedArrayBuffer is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SharedArrayBuffer[Symbol.species]
                    <pre><code>(function (){
  return SharedArrayBuffer[Symbol.species]() &#x3D;&#x3D;&#x3D; SharedArrayBuffer;
})()</code></pre>
                    <span>Result: ReferenceError: SharedArrayBuffer is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SharedArrayBuffer.prototype.byteLength
                    <pre><code>(function (){
  return &#x27;byteLength&#x27; in SharedArrayBuffer.prototype;
})()</code></pre>
                    <span>Result: ReferenceError: SharedArrayBuffer is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SharedArrayBuffer.prototype.slice
                    <pre><code>(function (){
  return typeof SharedArrayBuffer.prototype.slice &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SharedArrayBuffer is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - SharedArrayBuffer.prototype[Symbol.toStringTag]
                    <pre><code>(function (){
  return SharedArrayBuffer.prototype[Symbol.toStringTag] &#x3D;&#x3D;&#x3D; &#x27;SharedArrayBuffer&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: SharedArrayBuffer is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.add
                    <pre><code>(function (){
  return typeof Atomics.add &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.and
                    <pre><code>(function (){
  return typeof Atomics.and &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.compareExchange
                    <pre><code>(function (){
  return typeof Atomics.compareExchange &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.exchange
                    <pre><code>(function (){
  return typeof Atomics.exchange &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.wait
                    <pre><code>(function (){
  return typeof Atomics.wait &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.wake
                    <pre><code>(function (){
  return typeof Atomics.wake &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.isLockFree
                    <pre><code>(function (){
  return typeof Atomics.isLockFree &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.load
                    <pre><code>(function (){
  return typeof Atomics.load &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.or
                    <pre><code>(function (){
  return typeof Atomics.or &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.store
                    <pre><code>(function (){
  return typeof Atomics.store &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.sub
                    <pre><code>(function (){
  return typeof Atomics.sub &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Atomics.xor
                    <pre><code>(function (){
  return typeof Atomics.xor &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Atomics is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Async iteration

              <ul>
                <li>
                  FAIL - async generators
                    <pre><code>(function (){
  async function*generator(){
    yield 42;
  }

  var iterator &#x3D; generator();
  iterator.next().then(function(step){
    if(iterator[Symbol.asyncIterator]() &#x3D;&#x3D;&#x3D; iterator &amp;&amp; step.done &#x3D;&#x3D;&#x3D; false &amp;&amp; step.value &#x3D;&#x3D;&#x3D; 42)asyncTestPassed();
  });
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token function</span>
                    <span>Async: true</span>
                </li>
                <li>
                  FAIL - for-await-of loops
                    <pre><code>(function (){
  var asyncIterable &#x3D; {};
  asyncIterable[Symbol.asyncIterator] &#x3D; function(){
    var i &#x3D; 0;
    return {
      next: function(){
        switch(i++){
          case 1: return Promise.resolve({done: false, value: &#x27;a&#x27;});
          case 2: return Promise.resolve({done: false, value: &#x27;b&#x27;});
        } return Promise.resolve({done: true});
      }
    };
  };

  (async function(){
    var result &#x3D; &#x27;&#x27;;
    for await(var value of asyncIterable)result +&#x3D; value;
    if(result &#x3D;&#x3D;&#x3D; &#x27;ab&#x27;)asyncTestPassed();
  })();
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token function</span>
                    <span>Async: true</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - ArrayBuffer.transfer
              <pre><code>(function (){
  var buffer1 &#x3D; new Uint8Array([1, 2, 3]).buffer;
  var buffer2 &#x3D; ArrayBuffer.transfer(buffer1, 2);
  return buffer1.byteLength &#x3D;&#x3D;&#x3D; 0
    &amp;&amp; buffer2.byteLength &#x3D;&#x3D;&#x3D; 2
    &amp;&amp; new Uint8Array(buffer2)[0] &#x3D;&#x3D;&#x3D; 1;
})()</code></pre>
              <span>Result: TypeError: ArrayBuffer.transfer is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - class decorators
              <pre><code>(function (){
  class A {
    @nonconf
    get B() {}
  }
  function nonconf(target, name, descriptor) {
    descriptor.configurable &#x3D; false;
    return descriptor;
  }
  return Object.getOwnPropertyDescriptor(A.prototype, &quot;B&quot;).configurable &#x3D;&#x3D;&#x3D; false;
})()</code></pre>
              <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - class properties
              <pre><code>(function (){
  class C {
    x &#x3D; &#x27;x&#x27;;
    static y &#x3D; &#x27;y&#x27;;
  }
  return new C().x + C.y &#x3D;&#x3D;&#x3D; &#x27;xy&#x27;;
})()</code></pre>
              <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - string trimming

              <ul>
                <li>
                  SUCCESS - String.prototype.trimLeft
                    <pre><code>(function (){
  return &#x27; \t \n abc   \t\n&#x27;.trimLeft() &#x3D;&#x3D;&#x3D; &#x27;abc   \t\n&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - String.prototype.trimRight
                    <pre><code>(function (){
  return &#x27; \t \n abc   \t\n&#x27;.trimRight() &#x3D;&#x3D;&#x3D; &#x27; \t \n abc&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.trimStart
                    <pre><code>(function (){
  return &#x27; \t \n abc   \t\n&#x27;.trimStart() &#x3D;&#x3D;&#x3D; &#x27;abc   \t\n&#x27;;
})()</code></pre>
                    <span>Result: TypeError: &quot; 	 
 abc   	
&quot;.trimStart is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - String.prototype.trimEnd
                    <pre><code>(function (){
  return &#x27; \t \n abc   \t\n&#x27;.trimEnd() &#x3D;&#x3D;&#x3D; &#x27; \t \n abc&#x27;;
})()</code></pre>
                    <span>Result: TypeError: &quot; 	 
 abc   	
&quot;.trimEnd is not a function</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Observable

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  return typeof Observable !&#x3D;&#x3D; &#x27;undefined&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Symbol.observable well known symbol
                    <pre><code>(function (){
  return typeof Symbol.observable &#x3D;&#x3D;&#x3D; &#x27;symbol&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable.prototype.subscribe
                    <pre><code>(function (){
  return &#x27;subscribe&#x27; in Observable.prototype;
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable constructor behavior
                    <pre><code>(function (){
  if(!(new Observable(function(){}) instanceof Observable))return false;

  var nonCallableCheckPassed,
      primitiveCheckPassed,
      newCheckPassed;

  try { new Observable({ }) } catch(e) { nonCallableCheckPassed &#x3D; true }
  try { new Observable(false) } catch(e) { primitiveCheckPassed &#x3D; true }
  try { Observable(function() { }) } catch(e) { newCheckPassed &#x3D; true }

  return nonCallableCheckPassed &amp;&amp; primitiveCheckPassed &amp;&amp; newCheckPassed;
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable.prototype.forEach
                    <pre><code>(function (){
  var o &#x3D; new Observable(function() { });
  return &#x27;forEach&#x27; in Observable.prototype &amp;&amp; o.forEach(function(e){return true}) instanceof Promise;
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable.prototype[Symbol.observable]
                    <pre><code>(function (){
  var o &#x3D; new Observable(function() { });
  return Symbol.observable in Observable.prototype &amp;&amp; o[Symbol.observable]() &#x3D;&#x3D;&#x3D; o;
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable.of
                    <pre><code>(function (){
  return Observable.of(1, 2, 3) instanceof Observable;
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Observable.from
                    <pre><code>(function (){
  return (Observable.from([1,2,3,4]) instanceof Observable) &amp;&amp; (Observable.from(new Set([1, 2, 3])) instanceof Observable);
})()</code></pre>
                    <span>Result: ReferenceError: Observable is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - String.prototype.matchAll
              <pre><code>(function (){
  var iterator &#x3D; &#x27;11a2bb&#x27;.matchAll(/(\d)(\D)/);
  if(iterator[Symbol.iterator]() !&#x3D;&#x3D; iterator)return false;
  var a &#x3D; &#x27;&#x27;, b &#x3D; &#x27;&#x27;, c &#x3D; &#x27;&#x27;, step;
  while(!(step &#x3D; iterator.next()).done){
    a +&#x3D; step.value[0];
    b +&#x3D; step.value[1];
    c +&#x3D; step.value[2];
  }
  return a &#x3D;&#x3D;&#x3D; &#x27;1a2b&#x27;
    &amp;&amp; b &#x3D;&#x3D;&#x3D; &#x27;12&#x27;
    &amp;&amp; c &#x3D;&#x3D;&#x3D; &#x27;ab&#x27;;
})()</code></pre>
              <span>Result: TypeError: &quot;11a2bb&quot;.matchAll is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - weak references
              <pre><code>(function (){
  var O &#x3D; {};
  var weakref &#x3D; System.makeWeakRef(O);
  var works &#x3D; weakref.get() &#x3D;&#x3D;&#x3D; O;
  weakref.clear();
  return works &amp;&amp; weakref.get() &#x3D;&#x3D;&#x3D; undefined;
})()</code></pre>
              <span>Result: ReferenceError: System is not defined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - zones

              <ul>
                <li>
                  FAIL - Zone
                    <pre><code>(function (){
  return typeof Zone &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: false</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.current
                    <pre><code>(function (){
  return &#x27;current&#x27; in Zone;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.prototype.name
                    <pre><code>(function (){
  return &#x27;name&#x27; in Zone.prototype;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.prototype.parent
                    <pre><code>(function (){
  return &#x27;parent&#x27; in Zone.prototype;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.prototype.fork
                    <pre><code>(function (){
  return typeof Zone.prototype.fork &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.prototype.run
                    <pre><code>(function (){
  return typeof Zone.prototype.run &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Zone.prototype.wrap
                    <pre><code>(function (){
  return typeof Zone.prototype.wrap &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Zone is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - frozen realms
              <pre><code>(function (){
  return typeof Reflect.Realm.immutableRoot &#x3D;&#x3D;&#x3D; &#x27;function&#x27;
    &amp;&amp; typeof Reflect.Realm.prototype.spawn &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
              <span>Result: ReferenceError: Reflect is not defined</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - private fields

              <ul>
                <li>
                  FAIL - basic support
                    <pre><code>(function (){
  class C {
    #x;
    constructor(x){
      this.#x &#x3D; x;
    }
    x(){
      return this.#x;
    }
  }
  return new C(42).x() &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - initializers
                    <pre><code>(function (){
  class C {
    #x &#x3D; 42;
    x(){
      return this.#x;
    }
  }
  return new C().x() &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - bind (::) operator

              <ul>
                <li>
                  FAIL - binary form
                    <pre><code>(function (){
  function foo() { this.garply +&#x3D; &quot;foo&quot;; return this; }
  var obj &#x3D; { garply: &quot;bar&quot; };
  return typeof obj::foo &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; obj::foo().garply &#x3D;&#x3D;&#x3D; &quot;barfoo&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token :</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - unary form
                    <pre><code>(function (){
  var obj &#x3D; { garply: &quot;bar&quot;, foo: function() { this.garply +&#x3D; &quot;foo&quot;; return this; } };
  return typeof ::obj.foo &#x3D;&#x3D;&#x3D; &quot;function&quot; &amp;&amp; ::obj.foo().garply &#x3D;&#x3D;&#x3D; &quot;barfoo&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token :</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - do expression
              <pre><code>(function (){
  return do {
    let x &#x3D; 23;
    x + 19;
  } &#x3D;&#x3D;&#x3D; 42;
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token do</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Realms
              <pre><code>(function (){
  return typeof Realm &#x3D;&#x3D;&#x3D; &quot;function&quot;
    &amp;&amp; [&quot;eval&quot;, &quot;global&quot;, &quot;intrinsics&quot;, &quot;stdlib&quot;, &quot;directEval&quot;, &quot;indirectEval&quot;, &quot;initGlobal&quot;, &quot;nonEval&quot;].every(function(key){
      return key in Realm.prototype;
    });
})()</code></pre>
              <span>Result: false</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - String.prototype.at
              <pre><code>(function (){
  return &#x27;a𠮷b&#x27;.at(1) &#x3D;&#x3D;&#x3D; &#x27;𠮷&#x27;;
})()</code></pre>
              <span>Result: TypeError: &quot;aB·b&quot;.at is not a function</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Math methods for 64-bit integers

              <ul>
                <li>
                  FAIL - Math.iaddh
                    <pre><code>(function (){
  return Math.iaddh(0xffffffff, 1, 1, 1) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: TypeError: Math.iaddh is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Math.isubh
                    <pre><code>(function (){
  return Math.isubh(0, 4, 1, 1) &#x3D;&#x3D;&#x3D; 2;
})()</code></pre>
                    <span>Result: TypeError: Math.isubh is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Math.imulh
                    <pre><code>(function (){
  return Math.imulh(0xffffffff, 7) &#x3D;&#x3D;&#x3D; -1;
})()</code></pre>
                    <span>Result: TypeError: Math.imulh is not a function</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Math.umulh
                    <pre><code>(function (){
  return Math.umulh(0xffffffff, 7) &#x3D;&#x3D;&#x3D; 6;
})()</code></pre>
                    <span>Result: TypeError: Math.umulh is not a function</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - additional meta properties

              <ul>
                <li>
                  FAIL - function.callee
                    <pre><code>(function (){
  var f &#x3D; _ &#x3D;&gt; function.callee &#x3D;&#x3D;&#x3D; f;
  return f();
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - function.count
                    <pre><code>(function (){
  return (_ &#x3D;&gt; function.count)(1, 2, 3) &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - function.arguments
                    <pre><code>(function (){
  var arr &#x3D;  (_ &#x3D;&gt; function.arguments)(1, 2, 3);
  return Array.isArray(arr)
    &amp;&amp; arr.length &#x3D;&#x3D;&#x3D; 3
    &amp;&amp; arr[0] &#x3D;&#x3D;&#x3D; 1
    &amp;&amp; arr[1] &#x3D;&#x3D;&#x3D; 2
    &amp;&amp; arr[2] &#x3D;&#x3D;&#x3D; 3;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token .</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - method parameter decorators
              <pre><code>(function (){
  var target, key, index;
  function decorator(_target, _key, _index){
    target &#x3D; _target;
    key    &#x3D; _key;
    index  &#x3D; _index;
  }
  class C {
    method(@decorator foo){ }
  }
  return target &#x3D;&#x3D;&#x3D; C.prototype
    &amp;&amp; key &#x3D;&#x3D;&#x3D; &#x27;method&#x27;
    &amp;&amp; index &#x3D;&#x3D;&#x3D; 0;
})()</code></pre>
              <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - function expression decorators
              <pre><code>(function (){
  function inverse(f){
    return function(){
      return !f.apply(this, arguments);
    };
  }
  return (@inverse function(it){
    return it % 2;
  })(2);
})()</code></pre>
              <span>Result: SyntaxError: Unexpected token ILLEGAL</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - RegExp named capture groups
              <pre><code>(function (){
  var result &#x3D; /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/.exec(&#x27;2016-03-11&#x27;);
  return result.groups.year &#x3D;&#x3D;&#x3D; &#x27;2016&#x27;
    &amp;&amp; result.groups.month &#x3D;&#x3D;&#x3D; &#x27;03&#x27;
    &amp;&amp; result.groups.day &#x3D;&#x3D;&#x3D; &#x27;11&#x27;
    &amp;&amp; result.groups[0] &#x3D;&#x3D;&#x3D; &#x27;2016-03-11&#x27;
    &amp;&amp; result.groups[1] &#x3D;&#x3D;&#x3D; &#x27;2016&#x27;
    &amp;&amp; result.groups[2] &#x3D;&#x3D;&#x3D; &#x27;03&#x27;
    &amp;&amp; result.groups[3] &#x3D;&#x3D;&#x3D; &#x27;11&#x27;;
})()</code></pre>
              <span>Result: SyntaxError: Invalid regular expression: /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/: Invalid group</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - RegExp lookbehind
              <pre><code>(function (){
  return /(?&lt;&#x3D;a)b/.test(&#x27;ab&#x27;) &amp;&amp; /(?&lt;!a)b/.test(&#x27;cb&#x27;);
})()</code></pre>
              <span>Result: SyntaxError: Invalid regular expression: /(?&lt;&#x3D;a)b/: Invalid group</span>
              <span>Async: false</span>

          </li>
          <li>
            FAIL - Reflect.isCallable / Reflect.isConstructor

              <ul>
                <li>
                  FAIL - Reflect.isCallable
                    <pre><code>(function (){
  return Reflect.isCallable(function(){})
    &amp;&amp; Reflect.isCallable(_ &#x3D;&gt; _)
    &amp;&amp; !Reflect.isCallable(class {});
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.isConstructor
                    <pre><code>(function (){
  return Reflect.isConstructor(function(){})
    &amp;&amp; !Reflect.isConstructor(_ &#x3D;&gt; _)
    &amp;&amp; Reflect.isConstructor(class {});
})()</code></pre>
                    <span>Result: SyntaxError: Block-scoped declarations (let, const, function, class) not yet supported outside strict mode</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - asap
              <pre><code>(function (){
  var passed &#x3D; false;
  setTimeout(function(){ passed &#x3D; false; }, 1);
  asap(function(){ if(passed)asyncTestPassed(); });
  passed &#x3D; true;
})()</code></pre>
              <span>Result: ReferenceError: asap is not defined</span>
              <span>Async: true</span>

          </li>
          <li>
            FAIL - syntactic tail calls

              <ul>
                <li>
                  FAIL - direct recursion
                    <pre><code>(function (){
  &quot;use strict&quot;;
  return (function f(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;foo&quot;;
    }
    return continue f(n - 1);
  }(1e6)) &#x3D;&#x3D;&#x3D; &quot;foo&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token continue</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - mutual recursion
                    <pre><code>(function (){
  &quot;use strict&quot;;
  function f(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;foo&quot;;
    }
    return continue g(n - 1);
  }
  function g(n){
    if (n &lt;&#x3D; 0) {
      return  &quot;bar&quot;;
    }
    return continue f(n - 1);
  }
  return f(1e6) &#x3D;&#x3D;&#x3D; &quot;foo&quot; &amp;&amp; f(1e6+1) &#x3D;&#x3D;&#x3D; &quot;bar&quot;;
})()</code></pre>
                    <span>Result: SyntaxError: Unexpected token continue</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            FAIL - Metadata reflection API

              <ul>
                <li>
                  FAIL - Reflect.defineMetadata
                    <pre><code>(function (){
  return typeof Reflect.defineMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.hasMetadata
                    <pre><code>(function (){
  return typeof Reflect.hasMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.hasOwnMetadata
                    <pre><code>(function (){
  return typeof Reflect.hasOwnMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getMetadata
                    <pre><code>(function (){
  return typeof Reflect.getMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getOwnMetadata
                    <pre><code>(function (){
  return typeof Reflect.getOwnMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getMetadataKeys
                    <pre><code>(function (){
  return typeof Reflect.getMetadataKeys &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.getOwnMetadataKeys
                    <pre><code>(function (){
  return typeof Reflect.getOwnMetadataKeys &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.deleteMetadata
                    <pre><code>(function (){
  return typeof Reflect.deleteMetadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
                <li>
                  FAIL - Reflect.metadata
                    <pre><code>(function (){
  return typeof Reflect.metadata &#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: ReferenceError: Reflect is not defined</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
      </ul>

      <h2>esintl Features</h2>
      <ul>
          <li>
            SUCCESS - Intl object

              <ul>
                <li>
                  SUCCESS - exists on global
                    <pre><code>(function (){
  return typeof Intl &#x3D;&#x3D;&#x3D; &#x27;object&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - has prototype of Object
                    <pre><code>(function (){
  return Intl.constructor &#x3D;&#x3D;&#x3D; Object;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Intl.Collator

              <ul>
                <li>
                  SUCCESS - exists on intl object
                    <pre><code>(function (){
  return typeof Intl.Collator &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - creates new Collator instances
                    <pre><code>(function (){
  return new Intl.Collator() instanceof Intl.Collator;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor called without new creates instances
                    <pre><code>(function (){
  return Intl.Collator() instanceof Intl.Collator;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - calling Collator with Collator instance throws error
                    <pre><code>(function (){
  try {
    Intl.Collator.call(Intl.Collator());
    return false;
  } catch(e) {
    return e instanceof TypeError;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - accepts valid language tags
                    <pre><code>(function (){
  try {
    // Taken from https://github.com/tc39/test262/blob/83b07ff15eadb141c3d6f4d236a8733b720041d2/test/intl402/6.2.2_a.js
    var validLanguageTags &#x3D; [
      &quot;de&quot;, // ISO 639 language code
      &quot;de-DE&quot;, // + ISO 3166-1 country code
      &quot;DE-de&quot;, // tags are case-insensitive
      &quot;cmn&quot;, // ISO 639 language code
      &quot;cmn-Hans&quot;, // + script code
      &quot;CMN-hANS&quot;, // tags are case-insensitive
      &quot;cmn-hans-cn&quot;, // + ISO 3166-1 country code
      &quot;es-419&quot;, // + UN M.49 region code
      &quot;es-419-u-nu-latn-cu-bob&quot;, // + Unicode locale extension sequence
      &quot;i-klingon&quot;, // grandfathered tag
      &quot;cmn-hans-cn-t-ca-u-ca-x-t-u&quot;, // singleton subtags can also be used as private use subtags
      &quot;de-gregory-u-ca-gregory&quot;, // variant and extension subtags may be the same
      &quot;aa-a-foo-x-a-foo-bar&quot;, // variant subtags can also be used as private use subtags
      &quot;x-en-US-12345&quot;, // anything goes in private use tags
      &quot;x-12345-12345-en-US&quot;,
      &quot;x-en-US-12345-12345&quot;,
      &quot;x-en-u-foo&quot;,
      &quot;x-en-u-foo-u-bar&quot;
    ];
    for (var i in validLanguageTags) {
      Intl.Collator(validLanguageTags[i]);
    }
    return true;
  } catch(e) {
    return false;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Intl.Collator.prototype.compare

              <ul>
                <li>
                  SUCCESS - exists on Collator prototype
                    <pre><code>(function (){
  return typeof Intl.Collator().compare &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Intl.Collator.prototype.resolvedOptions

              <ul>
                <li>
                  SUCCESS - exists on Collator prototype
                    <pre><code>(function (){
  return typeof Intl.Collator().resolvedOptions &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - NumberFormat

              <ul>
                <li>
                  SUCCESS - exists on intl object
                    <pre><code>(function (){
  return typeof Intl.NumberFormat &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - exists on intl object
                    <pre><code>(function (){
  return typeof Intl.NumberFormat &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - creates new NumberFormat instances
                    <pre><code>(function (){
  return new Intl.NumberFormat() instanceof Intl.NumberFormat;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor called without new creates instances
                    <pre><code>(function (){
  return Intl.NumberFormat() instanceof Intl.NumberFormat;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - calling NumberFormat with NumberFormat instance throws error
                    <pre><code>(function (){
  try {
    Intl.NumberFormat.call(Intl.NumberFormat());
    return false;
  } catch(e) {
    return e instanceof TypeError;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - accepts valid language tags
                    <pre><code>(function (){
  try {
    // Taken from https://github.com/tc39/test262/blob/83b07ff15eadb141c3d6f4d236a8733b720041d2/test/intl402/6.2.2_a.js
    var validLanguageTags &#x3D; [
      &quot;de&quot;, // ISO 639 language code
      &quot;de-DE&quot;, // + ISO 3166-1 country code
      &quot;DE-de&quot;, // tags are case-insensitive
      &quot;cmn&quot;, // ISO 639 language code
      &quot;cmn-Hans&quot;, // + script code
      &quot;CMN-hANS&quot;, // tags are case-insensitive
      &quot;cmn-hans-cn&quot;, // + ISO 3166-1 country code
      &quot;es-419&quot;, // + UN M.49 region code
      &quot;es-419-u-nu-latn-cu-bob&quot;, // + Unicode locale extension sequence
      &quot;i-klingon&quot;, // grandfathered tag
      &quot;cmn-hans-cn-t-ca-u-ca-x-t-u&quot;, // singleton subtags can also be used as private use subtags
      &quot;de-gregory-u-ca-gregory&quot;, // variant and extension subtags may be the same
      &quot;aa-a-foo-x-a-foo-bar&quot;, // variant subtags can also be used as private use subtags
      &quot;x-en-US-12345&quot;, // anything goes in private use tags
      &quot;x-12345-12345-en-US&quot;,
      &quot;x-en-US-12345-12345&quot;,
      &quot;x-en-u-foo&quot;,
      &quot;x-en-u-foo-u-bar&quot;
    ];
    for (var i in validLanguageTags) {
      Intl.NumberFormat(validLanguageTags[i]);
    }
    return true;
  } catch(e) {
    return false;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - DateTimeFormat

              <ul>
                <li>
                  SUCCESS - exists on intl object
                    <pre><code>(function (){
  return typeof Intl.DateTimeFormat &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - creates new DateTimeFormat instances
                    <pre><code>(function (){
  return new Intl.DateTimeFormat() instanceof Intl.DateTimeFormat;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - constructor called without new creates instances
                    <pre><code>(function (){
  return Intl.DateTimeFormat() instanceof Intl.DateTimeFormat;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - calling DateTimeFormat with DateTimeFormat instance throws error
                    <pre><code>(function (){
  try {
    Intl.DateTimeFormat.call(Intl.DateTimeFormat());
    return false;
  } catch(e) {
    return e instanceof TypeError;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - accepts valid language tags
                    <pre><code>(function (){
  try {
    // Taken from https://github.com/tc39/test262/blob/83b07ff15eadb141c3d6f4d236a8733b720041d2/test/intl402/6.2.2_a.js
    var validLanguageTags &#x3D; [
      &quot;de&quot;, // ISO 639 language code
      &quot;de-DE&quot;, // + ISO 3166-1 country code
      &quot;DE-de&quot;, // tags are case-insensitive
      &quot;cmn&quot;, // ISO 639 language code
      &quot;cmn-Hans&quot;, // + script code
      &quot;CMN-hANS&quot;, // tags are case-insensitive
      &quot;cmn-hans-cn&quot;, // + ISO 3166-1 country code
      &quot;es-419&quot;, // + UN M.49 region code
      &quot;es-419-u-nu-latn-cu-bob&quot;, // + Unicode locale extension sequence
      &quot;i-klingon&quot;, // grandfathered tag
      &quot;cmn-hans-cn-t-ca-u-ca-x-t-u&quot;, // singleton subtags can also be used as private use subtags
      &quot;de-gregory-u-ca-gregory&quot;, // variant and extension subtags may be the same
      &quot;aa-a-foo-x-a-foo-bar&quot;, // variant subtags can also be used as private use subtags
      &quot;x-en-US-12345&quot;, // anything goes in private use tags
      &quot;x-12345-12345-en-US&quot;,
      &quot;x-en-US-12345-12345&quot;,
      &quot;x-en-u-foo&quot;,
      &quot;x-en-u-foo-u-bar&quot;
    ];
    for (var i in validLanguageTags) {
      Intl.DateTimeFormat(validLanguageTags[i]);
    }
    return true;
  } catch(e) {
    return false;
  }
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
                <li>
                  SUCCESS - resolvedOptions().timeZone defaults to the host environment
                    <pre><code>(function (){
  var tz &#x3D; Intl.DateTimeFormat().resolvedOptions().timeZone;
  return tz !&#x3D;&#x3D; undefined &amp;&amp; tz.length &gt; 0;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - String.prototype.localeCompare

              <ul>
                <li>
                  SUCCESS - exists on String prototype
                    <pre><code>(function (){
  return typeof String.prototype.localeCompare &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Number.prototype.toLocaleString

              <ul>
                <li>
                  SUCCESS - exists on Number prototype
                    <pre><code>(function (){
  return typeof Number.prototype.toLocaleString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Array.prototype.toLocaleString

              <ul>
                <li>
                  SUCCESS - exists on Array prototype
                    <pre><code>(function (){
  return typeof Array.prototype.toLocaleString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Object.prototype.toLocaleString

              <ul>
                <li>
                  SUCCESS - exists on Object prototype
                    <pre><code>(function (){
  return typeof Object.prototype.toLocaleString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Date.prototype.toLocaleString

              <ul>
                <li>
                  SUCCESS - exists on Date prototype
                    <pre><code>(function (){
  return typeof Date.prototype.toLocaleString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Date.prototype.toLocaleDateString

              <ul>
                <li>
                  SUCCESS - exists on Date prototype
                    <pre><code>(function (){
  return typeof Date.prototype.toLocaleDateString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
          <li>
            SUCCESS - Date.prototype.toLocaleTimeString

              <ul>
                <li>
                  SUCCESS - exists on Date prototype
                    <pre><code>(function (){
  return typeof Date.prototype.toLocaleTimeString &#x3D;&#x3D;&#x3D; &#x27;function&#x27;;
})()</code></pre>
                    <span>Result: true</span>
                    <span>Async: false</span>
                </li>
              </ul>
          </li>
      </ul>

      <p>We are looking for pull requests for additional tests on the
        <a href="https://github.com/CoffeeAndCode/whatdoeslambdasupport.com">open source Github project</a>.</p>
      <p>For an in depth look at what features are available across the major Node
        releases, check out the <a href="http://kangax.github.io/compat-table/">Kangax compatibility tables</a>.</p>
    </div>

    <footer>
      <div class="container">
        <p>Made with love by the web consultants at <a href="http://www.coffeeandcode.com/?utm_source=whatdoeslambdasupport.com&utm_medium=footer_link&utm_campaign=open_source">Coffee and Code</a>.
          Last built on Sun Apr 24 2016 21:49:12 GMT-0400 (EDT) with tests from Sun Apr 24 2016 16:29:07 GMT-0400 (EDT).</p>
      </div>
    </footer>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-43185016-7', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
